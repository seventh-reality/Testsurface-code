<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Advanced AR Model Interaction</title>
  <!-- A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  <!-- AR.js for fallback -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Hammer.js for gestures -->
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
  <!-- WebXR Polyfill for broader device support -->
  <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      font-family: -apple-system, Arial, sans-serif;
    }
    #ar-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 100;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 2px black;
      z-index: 10;
      pointer-events: none;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      margin: 0 20px;
    }
    #start-button {
      padding: 12px 24px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 20px;
      transition: background 0.3s;
    }
    #start-button:hover {
      background: #45a049;
    }
    #start-button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .unsupported {
      color: #ff4444;
      margin-top: 20px;
      text-align: center;
      max-width: 80%;
    }
    #surface-indicator {
      position: fixed;
      width: 40px;
      height: 40px;
      border: 2px solid rgba(255,255,255,0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 20;
      display: none;
      transition: transform 0.1s;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    #gesture-help {
      position: fixed;
      bottom: 60px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 15;
      display: none;
      margin: 0 20px;
    }
    #stability-meter {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 100px;
      height: 10px;
      background: rgba(255,255,255,0.2);
      border-radius: 5px;
      overflow: hidden;
      z-index: 30;
      display: none;
    }
    #stability-progress {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #ff4444, #ffbb33, #00C851);
      transition: width 0.3s;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
    #debug-info {
      position: fixed;
      top: 40px;
      left: 20px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      font-size: 12px;
      z-index: 30;
      display: none;
    }
  </style>
</head>
<body>
  <div id="loading">
    <h1>Advanced AR Model Interaction</h1>
    <p>Initializing AR environment...</p>
    <div id="support-message"></div>
    <button id="start-button">Start AR Experience</button>
  </div>

  <div id="info">Move device slowly to detect surfaces. Tap to place the model.</div>
  <div id="gesture-help">Use one finger to move, two fingers to rotate/scale</div>
  <div id="surface-indicator"></div>
  <div id="stability-meter"><div id="stability-progress"></div></div>
  <div id="debug-info"></div>
  
  <div id="ar-container"></div>

  <script>
    // Enhanced Configuration
    const config = {
      modelUrl: 'all.glb',
      debug: true,
      initialScale: 1.0,
      minScale: 0.1,
      maxScale: 2.0,
      stabilityThreshold: 0.05,
      modelUnits: 'meters',
      tracking: {
        planeDetection: true,
        stabilizationFrames: 30,
        minFeaturePoints: 30,
        hitTestRefreshRate: 10,
        environmentEstimation: true
      },
      reticle: {
        ringRadius: 0.15,
        ringThickness: 0.05,
        segments: 32,
        color: 0xffffff,
        opacity: 0.8,
        pulseSpeed: 0.5,
        pulseMin: 0.9,
        pulseMax: 1.1,
        circleRadius: 0.1,
        circleSegments: 24,
        gridSize: 0.3,
        gridDivisions: 8,
        gridColor: 0xffffff,
        gridOpacity: 0.3,
        stableColor: 0x00ff00,
        unstableColor: 0xff4444
      }
    };

    // Global variables
    let scene, camera, renderer;
    let model = null;
    let reticle = null;
    let reticlePulse = 1;
    let reticlePulseDirection = 1;
    let arjsScene = null;
    let isModelPlaced = false;
    let currentScale = config.initialScale;
    let lastPosition = new THREE.Vector3();
    let hammerManager = null;
    let initialDistance = 0;
    let initialScale = 1;
    let initialAngle = 0;
    let initialRotation = 0;
    let modelBoundingBox = new THREE.Box3();
    let modelAnchor = null;
    let modelGroup = null;
    let frameCounter = 0;
    let stabilityScore = 0;
    let hitTestCounter = 0;
    let lastStablePosition = null;
    let featurePoints = [];
    let planeMeshes = [];
    let isSessionStarted = false;
    let xrSession = null;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let referenceSpace = null;
    let lastHitTestPose = null;
    let lastStabilityUpdateTime = 0;

    // Enhanced WebXR support check
    async function checkXRSupport() {
      if (!navigator.xr) {
        if (window.WebXRPolyfill) {
          new WebXRPolyfill();
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        if (!navigator.xr) return false;
      }
      
      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (supported) {
          return true;
        } else {
          // Check for ARCore/ARKit support through user agent
          const userAgent = navigator.userAgent || navigator.vendor || window.opera;
          const isAndroid = /android/i.test(userAgent);
          const isIOS = /iPad|iPhone|iPod/.test(userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
          
          if ((isAndroid && !userAgent.includes('Chrome/')) || 
              (isIOS && !window.WebKitPlaybackTargetAvailabilityEvent)) {
            return false;
          }
          return false;
        }
      } catch (e) {
        console.error("XR support check failed:", e);
        return false;
      }
    }

    // Check camera permissions with enhanced error handling
    async function checkCameraPermissions() {
      try {
        if (navigator.permissions) {
          const permissionStatus = await navigator.permissions.query({ name: 'camera' });
          if (permissionStatus.state === 'denied') {
            return false;
          }
        }
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: { ideal: 'environment' },
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          } 
        });
        stream.getTracks().forEach(track => track.stop());
        return true;
      } catch (e) {
        console.error("Camera permission error:", e);
        return false;
      }
    }

    // Create advanced reticle with stability feedback
    function createReticle() {
      const reticleGroup = new THREE.Group();
      
      // Outer ring with stability indicator
      const ringGeometry = new THREE.RingGeometry(
        config.reticle.ringRadius, 
        config.reticle.ringRadius + config.reticle.ringThickness, 
        config.reticle.segments
      ).rotateX(-Math.PI / 2);
      
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: config.reticle.color,
        transparent: true,
        opacity: config.reticle.opacity,
        side: THREE.DoubleSide
      });
      
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      reticleGroup.add(ring);
      
      // Inner circle with subtle grid pattern
      const circleGeometry = new THREE.CircleGeometry(
        config.reticle.circleRadius, 
        config.reticle.circleSegments
      ).rotateX(-Math.PI / 2);
      
      const circleMaterial = new THREE.MeshBasicMaterial({
        color: config.reticle.color,
        transparent: true,
        opacity: config.reticle.opacity,
        side: THREE.DoubleSide
      });
      
      const circle = new THREE.Mesh(circleGeometry, circleMaterial);
      reticleGroup.add(circle);
      
      // Detailed grid mesh with adaptive resolution
      const gridGeometry = new THREE.PlaneGeometry(
        config.reticle.gridSize, 
        config.reticle.gridSize, 
        config.reticle.gridDivisions, 
        config.reticle.gridDivisions
      ).rotateX(-Math.PI / 2);
      
      const gridMaterial = new THREE.MeshBasicMaterial({
        color: config.reticle.gridColor,
        transparent: true,
        opacity: config.reticle.gridOpacity,
        wireframe: true
      });
      
      const grid = new THREE.Mesh(gridGeometry, gridMaterial);
      reticleGroup.add(grid);
      
      // Add small dots at grid intersections for better spatial perception
      const dotGeometry = new THREE.BufferGeometry();
      const positions = [];
      const size = config.reticle.gridSize;
      const divisions = config.reticle.gridDivisions;
      const step = size / divisions;
      
      for (let i = 0; i <= divisions; i++) {
        for (let j = 0; j <= divisions; j++) {
          positions.push(
            -size/2 + i * step,
            0,
            -size/2 + j * step
          );
        }
      }
      
      dotGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const dotMaterial = new THREE.PointsMaterial({
        color: config.reticle.gridColor,
        size: 0.005,
        transparent: true,
        opacity: config.reticle.gridOpacity * 1.5
      });
      
      const dots = new THREE.Points(dotGeometry, dotMaterial);
      reticleGroup.add(dots);
      
      reticleGroup.matrixAutoUpdate = false;
      reticleGroup.visible = false;
      reticleGroup.userData.materials = {
        ring: ringMaterial,
        circle: circleMaterial,
        grid: gridMaterial,
        dots: dotMaterial
      };
      
      return reticleGroup;
    }

    // Update reticle appearance based on stability
    function updateReticleStability(stability) {
      if (!reticle || !reticle.userData.materials) return;
      
      const color = new THREE.Color().lerpColors(
        new THREE.Color(config.reticle.unstableColor),
        new THREE.Color(config.reticle.stableColor),
        stability
      );
      
      Object.values(reticle.userData.materials).forEach(material => {
        if (material) {
          material.color.copy(color);
        }
      });
      
      // Update stability meter UI
      const stabilityProgress = document.getElementById('stability-progress');
      if (stabilityProgress) {
        stabilityProgress.style.width = `${stability * 100}%`;
      }
    }

    // Initialize WebXR with enhanced tracking features
    async function initWebXR() {
      try {
        const hasPermission = await checkCameraPermissions();
        if (!hasPermission) {
          showCameraError();
          return;
        }

        // Create Three.js scene with environment estimation
        scene = new THREE.Scene();
        scene.background = null;
        
        camera = new THREE.PerspectiveCamera(
          60, 
          window.innerWidth / window.innerHeight, 
          0.01, // Near plane very small for AR
          100
        );
        
        renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true,
          powerPreference: "high-performance",
          logarithmicDepthBuffer: true
        });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        renderer.xr.enabled = true;
        renderer.physicallyCorrectLights = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.getElementById('ar-container').appendChild(renderer.domElement);
        
        // Enhanced lighting for environment estimation
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0.5, 1, 0.25);
        directionalLight.castShadow = true;
        directionalLight.shadow.bias = -0.001;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Create advanced reticle
        reticle = createReticle();
        scene.add(reticle);
        // Modify your createReticle function to add this:
reticleGroup.userData = {
  lastPositions: [],
  addPosition: function(position) {
    this.lastPositions.push({ position, time: performance.now() });
    // Keep only recent positions
    if (this.lastPositions.length > 10) {
      this.lastPositions.shift();
    }
  },
  getStability: function() {
    if (this.lastPositions.length < 2) return 0;
    
    let totalMovement = 0;
    for (let i = 1; i < this.lastPositions.length; i++) {
      totalMovement += this.lastPositions[i].position.distanceTo(
        this.lastPositions[i-1].position
      );
    }
    
    const avgMovement = totalMovement / (this.lastPositions.length - 1);
    const timeSpan = this.lastPositions[this.lastPositions.length-1].time - 
                    this.lastPositions[0].time;
    
    // Normalize movement to meters per second
    const movementPerSecond = avgMovement / (timeSpan / 1000);
    
    // Convert to stability score (0-1)
    return Math.max(0, 1 - (movementPerSecond / config.tracking.stability.movementThreshold));
  }
};
        
        // Create a group to hold the model for stable positioning
        modelGroup = new THREE.Group();
        scene.add(modelGroup);
        
        // Load model with proper scaling and error handling
        const loader = new THREE.GLTFLoader();
        try {
          const gltf = await loader.loadAsync(config.modelUrl);
          model = gltf.scene;
          
          // Calculate bounding box to determine proper scale
          modelBoundingBox.setFromObject(model);
          const size = modelBoundingBox.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          
          // Adjust scale based on model size
          const targetSize = 1.0; // Target size in meters
          const scaleFactor = targetSize / maxDim;
          
          model.scale.set(scaleFactor, scaleFactor, scaleFactor);
          currentScale = scaleFactor;
          
          model.visible = false;
          modelGroup.add(model);
          
          if (config.debug) {
            console.log(`Model loaded with initial scale: ${scaleFactor.toFixed(2)}`);
            // Add bounding box helper for debugging
            const bboxHelper = new THREE.Box3Helper(modelBoundingBox, 0xffff00);
            bboxHelper.visible = false;
            model.add(bboxHelper);
          }
        } catch (e) {
          console.error("Failed to load model:", e);
          // Fallback cube with proper scaling
          model = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ 
              color: 0x00ff00,
              roughness: 0.7,
              metalness: 0.3
            })
          );
          model.castShadow = true;
          model.visible = false;
          modelGroup.add(model);
        }
        
        // Start AR session with enhanced features
        const sessionInit = { 
          requiredFeatures: ['hit-test', 'dom-overlay'],
          optionalFeatures: ['plane-detection', 'anchors', 'light-estimation', 'depth-sensing']
        };
        
        xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
        await renderer.xr.setSession(xrSession);
        
        // Set up reference space
        referenceSpace = await xrSession.requestReferenceSpace('local');
        
        // Enable plane detection if supported
        if (xrSession.enabledFeatures && xrSession.enabledFeatures.includes('plane-detection')) {
          referenceSpace = await xrSession.requestReferenceSpace('local-floor');
          const planeDetectionState = { enabled: true };
          xrSession.updateWorldTrackingState({ planeDetectionState });
        }
        
        // Enable light estimation if supported
        if (xrSession.enabledFeatures && xrSession.enabledFeatures.includes('light-estimation')) {
          const lightEstimationState = { enabled: true };
          xrSession.updateWorldTrackingState({ lightEstimationState });
        }
        
        isSessionStarted = true;
        document.getElementById('loading').style.display = 'none';
        document.getElementById('gesture-help').style.display = 'block';
        document.getElementById('surface-indicator').style.display = 'block';
        document.getElementById('stability-meter').style.display = 'block';
        if (config.debug) document.getElementById('debug-info').style.display = 'block';
        
        // Set up controller for placement
        const controller = renderer.xr.getController(0);
        controller.addEventListener('select', placeModel);
        scene.add(controller);
        
        // Set up hit test source for surface detection
        setupHitTestSource();
        
        // Set up gesture controls after model is placed
        setupGestureControls();
        
        // Start animation loop
        renderer.setAnimationLoop(render);
      } catch (e) {
        console.error("WebXR initialization failed:", e);
        fallbackToARJS();
      }
    }

    // Set up hit test source for surface detection
   // Replace the existing setupHitTestSource function with this improved version
async function setupHitTestSource() {
  if (!xrSession || !referenceSpace || hitTestSourceRequested) return;
  
  try {
    // First try with the most accurate configuration
    hitTestSource = await xrSession.requestHitTestSource({
      space: referenceSpace,
      entityTypes: ['plane', 'mesh'],
      offsetRay: new XRRay(new DOMPoint(0, 0, 0), { 
        direction: {x: 0, y: -1, z: 0, w: 1} // Pointing downward
      })
    });
    
    hitTestSourceRequested = true;
    
    // Add session end handler to clean up
    xrSession.addEventListener('end', () => {
      hitTestSourceRequested = false;
      if (hitTestSource) {
        hitTestSource.cancel();
        hitTestSource = null;
      }
    });
    
    if (config.debug) {
      console.log("Hit test source created successfully");
    }
  } catch (e) {
    console.error("Failed to create hit test source:", e);
    
    // Fallback to simpler configuration
    try {
      hitTestSource = await xrSession.requestHitTestSource({
        space: referenceSpace,
        entityTypes: ['plane']
      });
      
      hitTestSourceRequested = true;
      
      if (config.debug) {
        console.log("Fallback hit test source created successfully");
      }
    } catch (e) {
      console.error("Failed to create fallback hit test source:", e);
      // Last resort - try without specifying entity types
      try {
        hitTestSource = await xrSession.requestHitTestSource({
          space: referenceSpace
        });
        hitTestSourceRequested = true;
      } catch (e) {
        console.error("Completely failed to create hit test source:", e);
      }
    }
  }
}

// Replace the render function with this improved version
function render(timestamp, frame) {
  if (!frame) return;
  
  // Get the XRViewerPose for the current frame
  const pose = frame.getViewerPose(referenceSpace);
  if (!pose) return;
  
  // Update camera position
  camera.matrix.fromArray(pose.transform.matrix);
  camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
  camera.updateMatrixWorld(true);
  
  // Process hit test results if we have a hit test source
  if (hitTestSource && !isModelPlaced) {
    const hitTestResults = frame.getHitTestResults(hitTestSource);
    
    if (hitTestResults.length > 0) {
      const hit = hitTestResults[0];
      const hitPose = hit.getPose(referenceSpace);
      
      if (hitPose) {
        reticle.visible = true;
        reticle.matrix.fromArray(hitPose.transform.matrix);
        
        // Calculate stability metrics
        const currentPosition = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
        const currentTime = performance.now();
        
        if (lastStablePosition) {
          // Calculate movement since last frame
          const distanceMoved = lastStablePosition.distanceTo(currentPosition);
          const timeElapsed = currentTime - lastStabilityUpdateTime;
          
          // Normalize movement based on time
          const normalizedMovement = distanceMoved / Math.max(1, timeElapsed);
          
          // Update stability score (lower movement = higher stability)
          stabilityScore = Math.max(0, Math.min(1, 
            stabilityScore * 0.8 + (1 - Math.min(1, normalizedMovement * 10)) * 0.2
          ));
          
          // Update reticle appearance
          updateReticleStability(stabilityScore);
          
          // Update surface indicator
          updateSurfaceIndicator(currentPosition);
        }
        
        lastStablePosition = currentPosition.clone();
        lastStabilityUpdateTime = currentTime;
      }
    } else {
      reticle.visible = false;
      stabilityScore = 0;
      updateReticleStability(0);
      document.getElementById('surface-indicator').style.display = 'none';
    }
  }
  
  // Render the scene
  renderer.render(scene, camera);
}

// Improved surface indicator update
function updateSurfaceIndicator(position) {
  const indicator = document.getElementById('surface-indicator');
  if (!indicator) return;
  
  // Convert 3D position to 2D screen coordinates
  const vector = position.clone().project(camera);
  
  const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
  const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
  
  // Only show if position is in front of camera
  if (vector.z > 0 && vector.z <= 1) {
    indicator.style.left = `${x - 20}px`;
    indicator.style.top = `${y - 20}px`;
    indicator.style.display = 'block';
    
    // Add pulse animation based on stability
    const pulseScale = 0.8 + (0.4 * stabilityScore);
    indicator.style.transform = `scale(${pulseScale})`;
    indicator.style.opacity = stabilityScore;
  } else {
    indicator.style.display = 'none';
  }
}
// Add this to your initWebXR function after creating the session:
xrSession.addEventListener('inputsourceschange', (event) => {
  // Re-request hit test source if we lost it
  if (!hitTestSource && hitTestSourceRequested) {
    setupHitTestSource();
  }
});
    // Add this to your config:
    const tracking = {
  // ... existing config ...
  stability: {
    movementThreshold: 0.01, // meters per second
    timeWindow: 300,         // milliseconds
    requiredStableFrames: 10
  }
};

    // Initialize AR.js fallback mode with enhanced features
    async function initARJS() {
      try {
        const hasPermission = await checkCameraPermissions();
        if (!hasPermission) {
          showCameraError();
          return;
        }

        document.getElementById('ar-container').innerHTML = `
          <a-scene 
            vr-mode-ui="enabled: false"
            arjs="sourceType: webcam; 
                  detectionMode: mono_and_matrix; 
                  matrixCodeType: 3x3;
                  debugUIEnabled: false;
                  maxDetectionRate: 30;
                  cameraParametersUrl: https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/data/camera_para.dat"
            renderer="logarithmicDepthBuffer: true; precision: high; alpha: true"
            embedded
            cursor="rayOrigin: mouse; fuse: false"
            raycaster="objects: .clickable">
            
            <a-camera gps-camera rotation-reader></a-camera>
            
            <!-- Enhanced surface detection with multiple planes -->
            <a-entity id="surface-plane" 
                     geometry="primitive: plane; width: 100; height: 100" 
                     material="visible: false; shader: flat"
                     rotation="-90 0 0" 
                     class="clickable">
            </a-entity>
            
            <!-- Model with shadow -->
            <a-entity id="model" 
                     gltf-model="${config.modelUrl}" 
                     visible="false"
                     shadow="cast: true; receive: true">
            </a-entity>
            
            <!-- Enhanced AR.js reticle with stability feedback -->
            <a-entity id="arjs-reticle" visible="false">
              <a-ring color="white" 
                     radius-inner="${config.reticle.ringRadius}" 
                     radius-outer="${config.reticle.ringRadius + config.reticle.ringThickness}" 
                     opacity="${config.reticle.opacity}" 
                     rotation="-90 0 0">
              </a-ring>
              <a-circle color="white" 
                       radius="${config.reticle.circleRadius}" 
                       opacity="${config.reticle.opacity}" 
                       rotation="-90 0 0">
              </a-circle>
              <a-grid material="wireframe: true; color: white; opacity: ${config.reticle.gridOpacity}" 
                     width="${config.reticle.gridSize}" 
                     height="${config.reticle.gridSize}" 
                     rotation="-90 0 0">
              </a-grid>
            </a-entity>
            
            <!-- Lighting for better model appearance -->
            <a-light type="ambient" color="#ffffff" intensity="0.8"></a-light>
            <a-light type="directional" color="#ffffff" intensity="0.8" position="0.5 1 0.25" cast-shadow></a-light>
          </a-scene>
        `;
        
        arjsScene = document.querySelector('a-scene');
        const modelEl = document.getElementById('model');
        const reticleEl = document.getElementById('arjs-reticle');
        const surfacePlaneEl = document.getElementById('surface-plane');
        
        arjsScene.addEventListener('loaded', () => {
          document.getElementById('loading').style.display = 'none';
          document.getElementById('gesture-help').style.display = 'block';
          document.getElementById('stability-meter').style.display = 'block';
          
          // Wait for model to load to apply proper scaling
          modelEl.addEventListener('model-loaded', () => {
            const modelObject = modelEl.object3D;
            const box = new THREE.Box3().setFromObject(modelObject);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 1.0;
            const scaleFactor = targetSize / maxDim;
            
            modelEl.setAttribute('scale', {
              x: scaleFactor,
              y: scaleFactor,
              z: scaleFactor
            });
            
            if (config.debug) {
              console.log(`AR.js model scaled with factor: ${scaleFactor.toFixed(2)}`);
              // Add bounding box helper for debugging
              const bboxHelper = new THREE.Box3Helper(box, 0xffff00);
              bboxHelper.visible = false;
              modelObject.add(bboxHelper);
            }
          });
          
          // Enhanced surface detection with stability tracking
          let lastIntersectionTime = 0;
          let lastIntersectionPoint = null;
          let stabilityScore = 0;
          
          // Place model on surface click
          arjsScene.addEventListener('click', (e) => {
            if (!isModelPlaced && e.detail.intersection && 
                e.detail.intersection.object.el === surfacePlaneEl) {
              
              // Only place if stability is high enough
              if (stabilityScore > 0.7) {
                placeModelARJS(e.detail.intersection.point);
                reticleEl.setAttribute('visible', 'false');
              }
            }
          });
          
          // Show reticle when intersecting with surface
          arjsScene.addEventListener('mouseenter', (e) => {
            if (!isModelPlaced && e.detail.intersection && 
                e.detail.intersection.object.el === surfacePlaneEl) {
              
              const now = Date.now();
              const intersectionPoint = e.detail.intersection.point;
              
              // Calculate stability based on how much the intersection point has moved
              if (lastIntersectionPoint) {
                const distanceMoved = lastIntersectionPoint.distanceTo(intersectionPoint);
                const timeDiff = now - lastIntersectionTime;
                
                // Stability increases when movement is small and time difference is small
                const movementFactor = Math.max(0, 1 - distanceMoved * 10);
                const timeFactor = Math.min(1, timeDiff / 100);
                stabilityScore = Math.min(1, stabilityScore * 0.9 + movementFactor * timeFactor * 0.1);
                
                // Update stability UI
                document.getElementById('stability-progress').style.width = `${stabilityScore * 100}%`;
                
                // Update reticle color based on stability
                const color = new THREE.Color().lerpColors(
                  new THREE.Color(config.reticle.unstableColor),
                  new THREE.Color(config.reticle.stableColor),
                  stabilityScore
                );
                
                const colorHex = `#${color.getHexString()}`;
                reticleEl.setAttribute('color', colorHex);
                reticleEl.querySelector('a-ring').setAttribute('color', colorHex);
                reticleEl.querySelector('a-circle').setAttribute('color', colorHex);
                reticleEl.querySelector('a-grid').setAttribute('color', colorHex);
              }
              
              lastIntersectionPoint = intersectionPoint.clone();
              lastIntersectionTime = now;
              
              reticleEl.setAttribute('visible', 'true');
              reticleEl.setAttribute('position', intersectionPoint);
              
              // Update surface indicator
              updateARJSSurfaceIndicator(intersectionPoint);
            }
          });
          
          // Hide reticle when not intersecting with surface
          arjsScene.addEventListener('mouseleave', (e) => {
            if (!isModelPlaced) {
              reticleEl.setAttribute('visible', 'false');
              document.getElementById('surface-indicator').style.display = 'none';
              stabilityScore = 0;
              document.getElementById('stability-progress').style.width = '0%';
            }
          });
          
          // Set up gesture controls after model is placed
          setupARJSGestureControls(modelEl);
        });
      } catch (e) {
        console.error("AR.js initialization failed:", e);
        document.getElementById('support-message').innerHTML = 
          '<p class="unsupported">Failed to initialize AR. Your device may not support AR features.</p>';
      }
    }

    // Update surface indicator for AR.js
    function updateARJSSurfaceIndicator(position) {
      const indicator = document.getElementById('surface-indicator');
      if (!indicator) return;
      
      // Convert world position to screen coordinates
      const cameraEl = arjsScene.camera;
      const camera = cameraEl.object3D;
      const vector = new THREE.Vector3(
        position.x,
        position.y,
        position.z
      );
      
      vector.project(camera);
      
      const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
      const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
      
      indicator.style.left = `${x - 20}px`;
      indicator.style.top = `${y - 20}px`;
      indicator.style.display = 'block';
      
      // Add pulse animation based on stability
      const pulseScale = 1 + (0.2 * (1 - stabilityScore));
      indicator.style.transform = `scale(${pulseScale})`;
    }

    // Place model in WebXR mode with enhanced anchoring
    async function placeModel() {
      if (!isModelPlaced && reticle.visible && stabilityScore > 0.7) {
        try {
          // Create an anchor at the reticle position
          const anchorPose = new XRRigidTransform(
            new DOMPointReadOnly(reticle.position.x, reticle.position.y, reticle.position.z),
            { x: 0, y: 0, z: 0, w: 1 }
          );
          
          modelAnchor = await xrSession.createAnchor(anchorPose, referenceSpace);
          
          // Position the model group at the anchor's position
          modelGroup.position.set(0, 0, 0);
          model.visible = true;
          isModelPlaced = true;
          
          // Add the model group to the anchor's space
          const anchorGroup = new THREE.Group();
          anchorGroup.matrix.fromArray(modelAnchor.anchorSpace.getTransformTo(referenceSpace).matrix);
          anchorGroup.add(modelGroup);
          scene.add(anchorGroup);
          
          // Change reticle color to indicate placement
          updateReticleStability(1.0);
          
          // Hide surface indicator
          document.getElementById('surface-indicator').style.display = 'none';
          
          if (config.debug) {
            console.log("Model anchored to real world position");
            // Visualize the anchor point
            const anchorHelper = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 16, 16),
              new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            anchorHelper.position.setFromMatrixPosition(anchorGroup.matrix);
            scene.add(anchorHelper);
          }
        } catch (e) {
          console.error("Failed to create anchor:", e);
          // Fallback to non-anchored placement
          modelGroup.position.setFromMatrixPosition(reticle.matrix);
          modelGroup.quaternion.setFromRotationMatrix(reticle.matrix);
          model.visible = true;
          isModelPlaced = true;
        }
      }
    }

    // Place model in AR.js mode
    function placeModelARJS(position) {
      const modelEl = document.getElementById('model');
      modelEl.setAttribute('visible', 'true');
      modelEl.setAttribute('position', position);
      isModelPlaced = true;
      
      // Hide surface indicator
      document.getElementById('surface-indicator').style.display = 'none';
    }

    // Set up advanced gesture controls for WebXR
    function setupGestureControls() {
      const canvas = renderer.domElement;
      hammerManager = new Hammer.Manager(canvas, {
        recognizers: [
          [Hammer.Pan, { direction: Hammer.DIRECTION_ALL, threshold: 5 }],
          [Hammer.Pinch, { threshold: 0.1 }],
          [Hammer.Rotate, { threshold: 0.1 }]
        ]
      });
      
      // Single finger pan to move model
      hammerManager.on("panstart", (e) => {
        if (isModelPlaced) {
          lastPosition.copy(modelGroup.position);
        }
      });
      
      hammerManager.on("pan", (e) => {
        if (isModelPlaced && e.pointers.length === 1) {
          // Convert screen coordinates to world position using raycasting
          const vector = new THREE.Vector2(
            (e.center.x / window.innerWidth) * 2 - 1,
            -(e.center.y / window.innerHeight) * 2 + 1
          );
          
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(vector, camera);
          
          // Create a plane at the model's position for intersection
          const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(plane, intersection);
          
          if (intersection) {
            // Update model position relative to its anchor
            if (modelAnchor) {
              const anchorMatrix = new THREE.Matrix4().fromArray(
                modelAnchor.anchorSpace.getTransformTo(referenceSpace).matrix
              );
              const worldPosition = intersection.clone().sub(new THREE.Vector3().setFromMatrixPosition(anchorMatrix));
              modelGroup.position.copy(worldPosition);
            } else {
              modelGroup.position.copy(intersection);
            }
          }
        }
      });
      
      // Two finger pinch to scale model
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          initialScale = currentScale;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          currentScale = Math.min(config.maxScale, 
                                Math.max(config.minScale, initialScale * e.scale));
          model.scale.set(currentScale, currentScale, currentScale);
        }
      });
      
      // Two finger rotate to rotate model
      hammerManager.on("rotatestart", (e) => {
        if (isModelPlaced) {
          initialRotation = modelGroup.rotation.y;
        }
      });
      
      hammerManager.on("rotate", (e) => {
        if (isModelPlaced) {
          modelGroup.rotation.y = initialRotation + e.rotation * (Math.PI / 180);
        }
      });
      
      // Add inertia for smoother interaction
      hammerManager.on("panend", (e) => {
        // Could add inertia here if desired
      });
    }

    // Set up gesture controls for AR.js
 function setupARJSGestureControls(modelEl) {
      const container = document.getElementById('ar-container');
      hammerManager = new Hammer.Manager(container, {
        recognizers: [
          [Hammer.Pan, { direction: Hammer.DIRECTION_ALL, threshold: 5 }],
          [Hammer.Pinch, { threshold: 0.1 }],
          [Hammer.Rotate, { threshold: 0.1 }]
        ]
      });
      
      let startPosition = null;
      let startScale = config.initialScale;
      let startRotation = 0;
      
      // [Other event handlers remain the same]
      
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          startScale = modelEl.getAttribute('scale').x;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          const newScale = Math.min(config.maxScale, 
                                  Math.max(config.minScale, startScale * e.scale));
          modelEl.setAttribute('scale', {
            x: newScale,
            y: newScale,
            z: newScale
          });
        }
      });
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          startScale = modelEl.getAttribute('scale').x;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          const newScale = Math.min(config.maxScale, 
                                  Math.max(config.minScale, startScale * e.scale));
          modelEl.setAttribute('scale', {
            x: newScale,
            y: newScale,
            z: newScale
          });
        }
      });
      
      hammerManager.on("rotatestart", (e) => {
        if (isModelPlaced) {
          startRotation = modelEl.getAttribute('rotation').y || 0;
        }
      });
      
      hammerManager.on("rotate", (e) => {
        if (isModelPlaced) {
          const newRotation = startRotation + e.rotation;
          modelEl.setAttribute('rotation', {
            x: 0,
            y: newRotation,
            z: 0
          });
        }
      });
    }

    // Enhanced WebXR render loop with stability tracking
    function render(timestamp, frame) {
      if (!frame) return;
      
      // Store the frame for use in other functions
      window.frame = frame;
      
      // Update reticle pulse animation
      if (reticle && !isModelPlaced) {
        reticlePulse += config.reticle.pulseSpeed * 0.01 * reticlePulseDirection;
        if (reticlePulse > config.reticle.pulseMax || reticlePulse < config.reticle.pulseMin) {
          reticlePulseDirection *= -1;
        }
        
        reticle.scale.set(reticlePulse, reticlePulse, reticlePulse);
        
        // Get hit test results for surface detection
        const hitTestResults = frame.getHitTestResults(window.hitTestSource);
        
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);
          
          if (pose) {
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
            
            // Calculate stability based on how much the reticle has moved
            const currentPosition = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
            
            if (lastStablePosition) {
              const distanceMoved = lastStablePosition.distanceTo(currentPosition);
              const timeDiff = timestamp - lastStabilityUpdateTime;
              
              // Stability increases when movement is small and time difference is small
              const movementFactor = Math.max(0, 1 - distanceMoved * 10);
              const timeFactor = Math.min(1, timeDiff / 100);
              stabilityScore = Math.min(1, stabilityScore * 0.9 + movementFactor * timeFactor * 0.1);
              
              // Update reticle appearance based on stability
              updateReticleStability(stabilityScore);
            }
            
            lastStablePosition = currentPosition.clone();
            lastStabilityUpdateTime = timestamp;
            
            // Update surface indicator position
            updateSurfaceIndicator(currentPosition);
            
            if (config.debug) {
              // Show debug info
              const debugInfo = document.getElementById('debug-info');
              if (debugInfo) {
                debugInfo.innerHTML = `
                  Position: ${currentPosition.x.toFixed(2)}, ${currentPosition.y.toFixed(2)}, ${currentPosition.z.toFixed(2)}<br>
                  Stability: ${(stabilityScore * 100).toFixed(0)}%<br>
                  FPS: ${Math.round(renderer.info.render.frame / (performance.now() / 1000))}
                `;
              }
            }
          }
        } else {
          reticle.visible = false;
          stabilityScore = 0;
          updateReticleStability(0);
          document.getElementById('surface-indicator').style.display = 'none';
        }
      }
      
      // Request hit test source if not already done
      hitTestCounter++;
      if (hitTestCounter % config.tracking.hitTestRefreshRate === 0 && !hitTestSourceRequested) {
        setupHitTestSource();
      }
      
      renderer.render(scene, camera);
    }

    // Update surface indicator position for WebXR
    function updateSurfaceIndicator(position) {
      const indicator = document.getElementById('surface-indicator');
      if (!indicator) return;
      
      position.project(camera);
      
      const x = (position.x * 0.5 + 0.5) * window.innerWidth;
      const y = -(position.y * 0.5 - 0.5) * window.innerHeight;
      
      indicator.style.left = `${x - 20}px`;
      indicator.style.top = `${y - 20}px`;
      indicator.style.display = 'block';
      
      // Add pulse animation based on stability
      const pulseScale = 1 + (0.2 * (1 - stabilityScore));
      indicator.style.transform = `scale(${pulseScale})`;
    }

    // Show camera error message
    function showCameraError() {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('support-message').innerHTML = 
        '<p class="unsupported">Camera access was denied. Please enable camera permissions in your browser settings.</p>';
    }

    // Fallback to AR.js
    function fallbackToARJS() {
      console.log("Falling back to AR.js");
      document.getElementById('support-message').innerHTML = 
        '<p>Using fallback AR mode. For best experience, use a WebXR compatible device.</p>';
      initARJS();
    }

    // Handle window resize
    function onWindowResize() {
      if (camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight, false);
      }
    }

    // Start button event listener
    document.getElementById('start-button').addEventListener('click', async () => {
      const supported = await checkXRSupport();
      document.getElementById('start-button').disabled = true;
      
      if (supported) {
        initWebXR();
      } else {
        fallbackToARJS();
      }
    });

    // Initialize on load
    window.addEventListener('load', () => {
      window.addEventListener('resize', onWindowResize);
      
      // Check for WebXR support immediately to show appropriate UI
      checkXRSupport().then(supported => {
        if (!supported) {
          document.getElementById('support-message').innerHTML = 
            '<p>For the best experience, use a device with WebXR support (iOS 15+ or Android with Chrome 81+).</p>';
        }
      });
    });
  </script>
</body>
</html>
