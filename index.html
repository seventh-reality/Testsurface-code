<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>WebAR World Tracking</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    #camerafeed {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #ar-prompt {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      font-family: Arial, sans-serif;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      margin: 0 auto;
      width: 80%;
      border-radius: 20px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="camerafeed"></canvas>
  <div id="ar-prompt">Tap to place objects. Pinch with two fingers to reposition.</div>
  
  <!-- 8th Wall and Three.js libraries -->
  <script src="https://cdn.8thwall.com/web/xrweb/xrweb.js"></script>
  <script src="https://cdn.8thwall.com/web/xrextras/xrextras.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  
  <!-- Main app code -->
  <script>
// Copyright (c) 2021 8th Wall, Inc.

// Returns a pipeline module that initializes the threejs scene when the camera feed starts, and
// handles subsequent spawning of a glb model whenever the scene is tapped.

/* globals XR8 XRExtras THREE TWEEN */

const placegroundScenePipelineModule = () => {
  const modelFile = 'all.glb' // Free 3D model from 8th Wall samples
  const startScale = new THREE.Vector3(0.01, 0.01, 0.01)  // Initial scale value for our model
  const endScale = new THREE.Vector3(1, 1, 1)             // Ending scale value for our model
  const animationMillis = 750                             // Animate over 0.75 seconds

  const raycaster = new THREE.Raycaster()
  const tapPosition = new THREE.Vector2()
  const loader = new THREE.GLTFLoader()

  let surface  // Transparent surface for raycasting for object placement.

  // Populates some object into an XR scene and sets the initial camera position.
  const initXrScene = ({scene, camera, renderer}) => {
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap

    const light = new THREE.DirectionalLight(0xffffff, 1, 100)
    light.position.set(1, 4.3, 2.5)

    scene.add(light)
    scene.add(new THREE.AmbientLight(0x404040, 5))

    light.shadow.mapSize.width = 1024
    light.shadow.mapSize.height = 1024
    light.shadow.camera.near = 0.5
    light.shadow.camera.far = 500
    light.castShadow = true

    surface = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100, 1, 1),
      new THREE.ShadowMaterial({
        opacity: 0.5,
      })
    )

    surface.rotateX(-Math.PI / 2)
    surface.position.set(0, 0, 0)
    surface.receiveShadow = true
    scene.add(surface)

    camera.position.set(0, 3, 0)
  }

  const animateIn = (model, pointX, pointZ, yDegrees) => {
    const scale = {...startScale}

    model.scene.rotation.set(0.0, yDegrees, 0.0)
    model.scene.position.set(pointX, 0.0, pointZ)
    model.scene.scale.set(scale.x, scale.y, scale.z)
    
    // Enable shadows if model has mesh components
    model.scene.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true
      }
    })
    
    XR8.Threejs.xrScene().scene.add(model.scene)

    new TWEEN.Tween(scale)
      .to(endScale, animationMillis)
      .easing(TWEEN.Easing.Elastic.Out)
      .onUpdate(() => {
        model.scene.scale.set(scale.x, scale.y, scale.z)
      })
      .start()
  }

  // Load the glb model at the requested point on the surface.
  const placeObject = (pointX, pointZ) => {
    loader.load(
      modelFile,
      (gltf) => {
        animateIn(gltf, pointX, pointZ, Math.random() * 360)
      },
      undefined,
      (error) => {
        console.error('Error loading model:', error)
      }
    )
  }

  const placeObjectTouchHandler = (e) => {
    // Recenter when canvas is tapped with two fingers
    if (e.touches.length === 2) {
      XR8.XrController.recenter()
      return
    }

    if (e.touches.length > 2) {
      return
    }

    // Single tap - place object
    const {camera} = XR8.Threejs.xrScene()

    tapPosition.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1
    tapPosition.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1

    raycaster.setFromCamera(tapPosition, camera)
    const intersects = raycaster.intersectObject(surface)

    if (intersects.length === 1 && intersects[0].object === surface) {
      placeObject(intersects[0].point.x, intersects[0].point.z)
    }
  }

  return {
    name: 'placeground',

    onStart: ({canvas}) => {
      const {scene, camera, renderer} = XR8.Threejs.xrScene()

      initXrScene({scene, camera, renderer})
      canvas.addEventListener('touchstart', placeObjectTouchHandler, true)

      // Prevent scroll/pinch gestures on canvas
      canvas.addEventListener('touchmove', (event) => {
        event.preventDefault()
      })

      // Enable TWEEN animations
      const animate = (time) => {
        requestAnimationFrame(animate)
        TWEEN.update(time)
      }
      animate()

      XR8.XrController.updateCameraProjectionMatrix({
        origin: camera.position,
        facing: camera.quaternion,
      })
    },
  }
}

const onxrloaded = () => {
  XR8.addCameraPipelineModules([
    XR8.GlTextureRenderer.pipelineModule(),      // Draws the camera feed
    XR8.Threejs.pipelineModule(),               // Creates a ThreeJS AR Scene
    XR8.XrController.pipelineModule(),          // Enables SLAM tracking
    XRExtras.AlmostThere.pipelineModule(),      // Detects unsupported browsers
    XRExtras.FullWindowCanvas.pipelineModule(), // Modifies the canvas to fill the window
    XRExtras.Loading.pipelineModule(),          // Manages the loading screen
    XRExtras.RuntimeError.pipelineModule(),     // Shows an error image on error
    placegroundScenePipelineModule(),           // Our custom module
  ])

  XR8.run({canvas: document.getElementById('camerafeed')})
}

// Show loading screen before the full XR library has been loaded.
const load = () => { XRExtras.Loading.showLoading({onxrloaded}) }
window.onload = () => { window.XRExtras ? load() : window.addEventListener('xrextrasloaded', load) }
  </script>
</body>
</html>
