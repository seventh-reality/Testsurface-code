<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Advanced WebXR AR Experience</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/XRControllerModelFactory.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        #ar-container { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
        }
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
        }
        #loading { margin-bottom: 10px; }
        #error { 
            color: #ff4444; 
            margin: 10px 0;
            display: none;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #4285f4;
            color: white;
            font-size: 14px;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }
        button:hover { background-color: #3367d6; }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        #reticle {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 10;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="ar-container"></div>
    <div id="reticle"></div>
    
    <div id="ui">
        <div id="loading">
            <div id="progress">Initializing WebXR...</div>
        </div>
        <div id="error"></div>
        <button id="start-button" disabled>Start AR</button>
        <button id="permission-button" style="display: none;">Allow Camera Access</button>
    </div>

    <script>
        // Configuration
        const config = {
            modelUrl: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf',
            modelScale: 0.3,
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body },
            reticleColor: 0x00ff00
        };

        // Global variables
        let scene, camera, renderer, xrSession;
        let hitTestSource = null, model = null;
        let reticleMesh = null;
        let gltfLoader;
        let cameraPermissionGranted = false;
        let xrRefSpace = null;
        let controller = null;
        let controllerGrip = null;
        let resourcesLoaded = false;
        let arSupported = false;
        let modelPlaced = false;
        let reticleVisible = false;

        // Initialize the app
        init();

        function init() {
            setupScene();
            setupEventListeners();
            checkARSupport();
        }

        function setupScene() {
            // Create scene
            scene = new THREE.Scene();
            
            // Setup camera
            camera = new THREE.PerspectiveCamera(
                70, 
                window.innerWidth / window.innerHeight, 
                0.01, 
                100
            );
            scene.add(camera);

            // Setup renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            document.getElementById('ar-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Reticle for placement
            const reticleGeometry = new THREE.RingGeometry(0.1, 0.2, 32);
            reticleGeometry.rotateX(-Math.PI / 2);
            const reticleMaterial = new THREE.MeshBasicMaterial({ 
                color: config.reticleColor,
                transparent: true,
                opacity: 0.8
            });
            reticleMesh = new THREE.Mesh(reticleGeometry, reticleMaterial);
            reticleMesh.matrixAutoUpdate = false;
            reticleMesh.visible = false;
            scene.add(reticleMesh);

            // Setup loading manager
            const loadingManager = new THREE.LoadingManager(
                () => {
                    resourcesLoaded = true;
                    updateUI();
                },
                (url, itemsLoaded, itemsTotal) => {
                    const progress = Math.round(itemsLoaded / itemsTotal * 100);
                    document.getElementById('progress').textContent = `Loading ${progress}%`;
                },
                (url) => {
                    showError(`Failed to load resource: ${url}`);
                }
            );

            gltfLoader = new THREE.GLTFLoader(loadingManager);
            loadModel();

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupEventListeners() {
            document.getElementById('start-button').addEventListener('click', startAR);
            document.getElementById('permission-button').addEventListener('click', requestCameraPermission);
        }

        function checkARSupport() {
            updateProgress("Checking AR support...");

            if (!navigator.xr) {
                showError("WebXR not supported in this browser");
                return;
            }

            navigator.xr.isSessionSupported('immersive-ar')
                .then(supported => {
                    arSupported = supported;
                    if (supported) {
                        updateProgress("AR supported");
                        checkCameraPermissions();
                    } else {
                        showError("AR not supported on this device");
                    }
                    updateUI();
                })
                .catch(err => {
                    console.error("WebXR support check failed:", err);
                    showError("Error checking AR support");
                });
        }

        async function checkCameraPermissions() {
            try {
                if (navigator.permissions && navigator.permissions.query) {
                    const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                    cameraPermissionGranted = permissionStatus.state === 'granted';
                    
                    permissionStatus.onchange = () => {
                        cameraPermissionGranted = permissionStatus.state === 'granted';
                        updateUI();
                    };
                }
            } catch (err) {
                console.log("Camera permission API not available:", err);
                // Continue without permissions API
            }
            updateUI();
        }

        function loadModel() {
            updateProgress("Loading 3D model...");
            
            gltfLoader.load(config.modelUrl, 
                gltf => {
                    model = gltf.scene;
                    model.scale.set(config.modelScale, config.modelScale, config.modelScale);
                    model.visible = false;
                    
                    // Enable shadows if needed
                    model.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(model);
                },
                undefined,
                error => {
                    console.error("Model loading error:", error);
                    showError("Failed to load 3D model");
                }
            );
        }

        function updateProgress(message) {
            document.getElementById('progress').textContent = message;
        }

        function showError(message) {
            const errorElement = document.getElementById('error');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            console.error(message);
        }

        function updateUI() {
            const startButton = document.getElementById('start-button');
            const permissionButton = document.getElementById('permission-button');
            
            if (!arSupported) {
                startButton.disabled = true;
                return;
            }

            if (!cameraPermissionGranted) {
                permissionButton.style.display = 'block';
                startButton.disabled = true;
            } else {
                permissionButton.style.display = 'none';
                startButton.disabled = !resourcesLoaded;
            }

            if (resourcesLoaded && cameraPermissionGranted) {
                updateProgress("Ready to start AR");
            }
        }

        async function requestCameraPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop());
                cameraPermissionGranted = true;
                updateUI();
            } catch (err) {
                console.error("Camera permission error:", err);
                showError("Camera access denied. Please allow camera access.");
            }
        }

        async function startAR() {
            if (!arSupported) {
                showError("AR not supported");
                return;
            }

            if (!cameraPermissionGranted) {
                showError("Camera permission required");
                return;
            }

            try {
                updateProgress("Starting AR session...");
                
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: config.requiredFeatures,
                    optionalFeatures: config.optionalFeatures,
                    domOverlay: config.domOverlay
                });

                setupARSession();
            } catch (err) {
                console.error("Session start error:", err);
                showError("Failed to start AR: " + err.message);
                
                if (err.name === 'NotAllowedError') {
                    document.getElementById('permission-button').style.display = 'block';
                }
            }
        }

        function setupARSession() {
            // Hide UI during AR session
            document.getElementById('ui').style.display = 'none';

            // Set up session event handlers
            xrSession.addEventListener('end', onSessionEnd);
            
            // Set up renderer
            renderer.xr.setSession(xrSession)
                .then(() => {
                    // Request reference spaces
                    return Promise.all([
                        xrSession.requestReferenceSpace('local'),
                        xrSession.requestReferenceSpace('viewer')
                    ]);
                })
                .then(([localRefSpace, viewerRefSpace]) => {
                    xrRefSpace = localRefSpace;
                    
                    // Set up hit test source
                    return xrSession.requestHitTestSource({
                        space: viewerRefSpace,
                        entityTypes: ['plane', 'mesh']
                    });
                })
                .then(source => {
                    hitTestSource = source;
                    
                    // Set up controller if available
                    if (xrSession.inputSources && xrSession.inputSources.length > 0) {
                        setupController(xrSession.inputSources[0]);
                    }
                    xrSession.addEventListener('inputsourceschange', onInputSourcesChange);
                    
                    // Start render loop
                    renderer.setAnimationLoop(onXRFrame);
                })
                .catch(err => {
                    console.error("AR setup error:", err);
                    showError("AR setup failed: " + err.message);
                    if (xrSession) xrSession.end();
                });
        }

        function onInputSourcesChange(event) {
            if (event.added && event.added.length > 0) {
                setupController(event.added[0]);
            }
            if (event.removed && event.removed.length > 0) {
                cleanupController();
            }
        }

        function setupController(inputSource) {
            if (controller) cleanupController();
            
            const controllerModelFactory = new XRControllerModelFactory();

            controller = renderer.xr.getController(0);
            controller.addEventListener('selectstart', onSelectStart);
            controller.addEventListener('selectend', onSelectEnd);
            scene.add(controller);

            controllerGrip = renderer.xr.getControllerGrip(0);
            controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
            scene.add(controllerGrip);
        }

        function cleanupController() {
            if (controller) {
                controller.removeEventListener('selectstart', onSelectStart);
                controller.removeEventListener('selectend', onSelectEnd);
                scene.remove(controller);
                controller = null;
            }
            if (controllerGrip) {
                scene.remove(controllerGrip);
                controllerGrip = null;
            }
        }

        function onSelectStart() {
            if (model && reticleVisible && !modelPlaced) {
                modelPlaced = true;
                model.position.copy(reticleMesh.position);
                model.quaternion.copy(reticleMesh.quaternion);
                model.visible = true;
                
                // Update screen reticle
                document.getElementById('reticle').style.display = 'none';
            }
        }

        function onSelectEnd() {
            // Handle select end if needed
        }

        function onXRFrame(time, frame) {
            if (!frame || !xrSession) return;

            // Get viewer pose and hit test results
            const pose = frame.getViewerPose(xrRefSpace);
            let hitPose = null;

            if (pose && hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    hitPose = hitTestResults[0].getPose(xrRefSpace);
                }
            }

            // Update reticle based on hit test
            if (hitPose && !modelPlaced) {
                reticleMesh.visible = true;
                reticleMesh.matrix.fromArray(hitPose.transform.matrix);
                reticleVisible = true;
                
                // Update screen reticle position
                const pos = new THREE.Vector3().setFromMatrixPosition(reticleMesh.matrix);
                const clipPos = pos.clone().project(camera);
                const x = (clipPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (clipPos.y * -0.5 + 0.5) * window.innerHeight;
                const reticle = document.getElementById('reticle');
                reticle.style.display = 'block';
                reticle.style.left = `${x}px`;
                reticle.style.top = `${y}px`;
            } else {
                reticleMesh.visible = false;
                reticleVisible = false;
                document.getElementById('reticle').style.display = 'none';
            }

            renderer.render(scene, camera);
        }

        function onSessionEnd() {
            // Clean up session
            if (xrSession) {
                xrSession.removeEventListener('end', onSessionEnd);
                xrSession.removeEventListener('inputsourceschange', onInputSourcesChange);
                xrSession = null;
            }

            // Reset state
            modelPlaced = false;
            reticleVisible = false;
            hitTestSource = null;
            xrRefSpace = null;
            
            if (model) {
                model.visible = false;
            }
            
            cleanupController();
            renderer.setAnimationLoop(null);
            
            // Restore UI
            document.getElementById('ui').style.display = 'block';
            document.getElementById('reticle').style.display = 'none';
        }
    </script>
</body>
</html>
