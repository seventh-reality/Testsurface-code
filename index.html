<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Advanced SLAM AR with Surface Mesh Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        #reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            margin-left: -25px;
            margin-top: -25px;
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 99;
            transition: all 0.1s;
            display: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.8);
            padding: 25px;
            border-radius: 15px;
            z-index: 100;
            text-align: center;
            max-width: 80%;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            z-index: 100;
        }
        
        .control-button {
            padding: 12px 24px;
            background: linear-gradient(145deg, rgba(0,150,255,0.8), rgba(0,80,200,0.8));
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s;
            min-width: 120px;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        
        #toggle-mesh-button {
            background: linear-gradient(145deg, rgba(100,255,100,0.8), rgba(0,180,0,0.8));
        }
        
        a-scene {
            position: absolute;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="info">Advanced SLAM AR with Surface Mesh Visualization | Look around to detect surfaces</div>
    <div id="reticle"></div>
    <div id="loading">Initializing AR experience...</div>
    
    <div id="controls">
        <button id="start-button" class="control-button">Start AR</button>
        <button id="place-button" class="control-button" style="display: none;">Place Object</button>
        <button id="toggle-mesh-button" class="control-button" style="display: none;">Show Surface Mesh</button>
    </div>

    <!-- A-Frame Scene -->
    <a-scene 
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; precision: high; antialias: true;"
        embedded 
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
    >
        <!-- Camera -->
        <a-entity camera></a-entity>
        
        <!-- Lighting -->
        <a-entity light="type: ambient; color: #888; intensity: 0.5"></a-entity>
        <a-entity light="type: directional; color: #fff; intensity: 0.8; position: 1 1 1"></a-entity>
        
        <!-- This will be our dynamic content -->
        <a-entity id="dynamic-content"></a-entity>
        
        <!-- Surface mesh visualization -->
        <a-entity id="surface-mesh" visible="false"></a-entity>
    </a-scene>

    <script>
        // Wait for A-Frame to be ready
        window.addEventListener('load', async () => {
            const scene = document.querySelector('a-scene');
            const reticle = document.getElementById('reticle');
            const loading = document.getElementById('loading');
            const startButton = document.getElementById('start-button');
            const placeButton = document.getElementById('place-button');
            const toggleMeshButton = document.getElementById('toggle-mesh-button');
            const dynamicContent = document.getElementById('dynamic-content');
            const surfaceMesh = document.getElementById('surface-mesh');
            
            // Model URL
            const modelUrl = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r132/examples/models/gltf/Duck/glTF/Duck.gltf';
            
            // Track AR state
            let hasSurfaceDetection = false;
            let hitTestSource = null;
            let hitTestSourceInitialized = false;
            let modelPlaced = false;
            let lastHitPose = null;
            let showSurfaceMesh = false;
            let meshEntities = [];
            
            // Initialize AR.js with SLAM
            async function initARSession() {
                loading.textContent = "Initializing AR...";
                
                // Wait for scene to be ready
                await new Promise(resolve => {
                    if (scene.hasLoaded) resolve();
                    else scene.addEventListener('loaded', resolve);
                });
                
                // Get the Three.js renderer and camera
                const renderer = scene.renderer;
                const camera = scene.camera;
                const session = scene.systems["arjs"]._arSession;
                const referenceSpace = scene.systems["arjs"]._arReferenceSpace;
                
                // Enable advanced features if available
                if (session && session.requestHitTestSource) {
                    try {
                        // Request hit test source for world tracking
                        hitTestSource = await session.requestHitTestSource({
                            space: referenceSpace
                        });
                        hitTestSourceInitialized = true;
                        
                        // Show UI elements
                        reticle.style.display = 'block';
                        placeButton.style.display = 'block';
                        toggleMeshButton.style.display = 'block';
                        hasSurfaceDetection = true;
                        
                        // Start animation loop
                        renderer.setAnimationLoop(function(timestamp, frame) {
                            if (!frame) return;
                            
                            // Handle hit test if not placed yet
                            if (!modelPlaced && hitTestSourceInitialized) {
                                const hitTestResults = frame.getHitTestResults(hitTestSource);
                                
                                if (hitTestResults.length > 0) {
                                    const hit = hitTestResults[0];
                                    lastHitPose = hit.getPose(referenceSpace);
                                    
                                    // Update reticle position and appearance
                                    const position = lastHitPose.transform.position;
                                    const point = new THREE.Vector3(position.x, position.y, position.z);
                                    point.applyMatrix4(camera.matrixWorldInverse);
                                    
                                    // Convert to screen coordinates for reticle
                                    const vector = point.clone().project(camera);
                                    vector.x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                                    vector.y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
                                    
                                    reticle.style.left = `${vector.x}px`;
                                    reticle.style.top = `${vector.y}px`;
                                    reticle.style.borderColor = 'rgba(0, 255, 255, 0.9)';
                                    reticle.style.boxShadow = '0 0 15px rgba(0, 255, 255, 0.7)';
                                    
                                    // Update surface mesh visualization
                                    if (showSurfaceMesh) {
                                        updateSurfaceMeshVisualization(hitTestResults, referenceSpace);
                                    }
                                } else {
                                    reticle.style.borderColor = 'rgba(255, 255, 0, 0.6)';
                                    reticle.style.boxShadow = '0 0 10px rgba(255, 255, 0, 0.4)';
                                }
                            }
                        });
                        
                        loading.style.display = 'none';
                        startButton.style.display = 'none';
                        
                    } catch (error) {
                        console.error("Hit test failed:", error);
                        loading.textContent = "Advanced AR features not supported. Falling back to basic AR.";
                        hasSurfaceDetection = false;
                        reticle.style.display = 'none';
                    }
                } else {
                    loading.textContent = "World tracking not supported. Using basic AR.";
                    hasSurfaceDetection = false;
                    reticle.style.display = 'none';
                }
            }
            
            // Update surface mesh visualization
            function updateSurfaceMeshVisualization(hitTestResults, referenceSpace) {
                // Clear previous mesh entities
                meshEntities.forEach(entity => {
                    if (entity.parentNode) {
                        entity.parentNode.removeChild(entity);
                    }
                });
                meshEntities = [];
                
                // Create a new mesh for each hit test result
                hitTestResults.forEach((hit, index) => {
                    const pose = hit.getPose(referenceSpace);
                    if (!pose) return;
                    
                    // Create a mesh entity
                    const meshEntity = document.createElement('a-entity');
                    
                    // Create a small plane at the hit position
                    meshEntity.setAttribute('geometry', {
                        primitive: 'plane',
                        width: 0.2,
                        height: 0.2
                    });
                    
                    // Position and orient the plane
                    meshEntity.setAttribute('position', {
                        x: pose.transform.position.x,
                        y: pose.transform.position.y,
                        z: pose.transform.position.z
                    });
                    
                    // Align with the surface normal
                    const rotation = new THREE.Quaternion();
                    rotation.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        new THREE.Vector3(0, 1, 0) // Adjust based on actual normal if available
                    );
                    meshEntity.setAttribute('rotation', new THREE.Euler().setFromQuaternion(rotation));
                    
                    // White semi-transparent material
                    meshEntity.setAttribute('material', {
                        color: '#FFFFFF',
                        opacity: 0.7,
                        transparent: true,
                        wireframe: false
                    });
                    
                    surfaceMesh.appendChild(meshEntity);
                    meshEntities.push(meshEntity);
                });
            }
            
            // Toggle surface mesh visualization
            function toggleSurfaceMesh() {
                showSurfaceMesh = !showSurfaceMesh;
                surfaceMesh.setAttribute('visible', showSurfaceMesh);
                
                if (showSurfaceMesh) {
                    toggleMeshButton.textContent = 'Hide Mesh';
                    toggleMeshButton.style.background = 'linear-gradient(145deg, rgba(255,100,100,0.8), rgba(200,50,50,0.8))';
                } else {
                    toggleMeshButton.textContent = 'Show Mesh';
                    toggleMeshButton.style.background = 'linear-gradient(145deg, rgba(100,255,100,0.8), rgba(0,180,0,0.8))';
                    
                    // Clear all mesh entities when hiding
                    meshEntities.forEach(entity => {
                        if (entity.parentNode) {
                            entity.parentNode.removeChild(entity);
                        }
                    });
                    meshEntities = [];
                }
            }
            
            // Place model at reticle position
            function placeModel() {
                if (modelPlaced) return;
                
                // Get camera position and direction
                const camera = scene.camera;
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(camera.quaternion);
                
                let position, rotation;
                
                if (hasSurfaceDetection && lastHitPose) {
                    // Place at hit test position
                    position = new THREE.Vector3(
                        lastHitPose.transform.position.x,
                        lastHitPose.transform.position.y,
                        lastHitPose.transform.position.z
                    );
                    
                    // Align with surface normal if available
                    rotation = new THREE.Quaternion().copy(camera.quaternion);
                } else {
                    // Place 1 meter in front of camera as fallback
                    position = new THREE.Vector3();
                    camera.getWorldPosition(position);
                    position.add(direction.multiplyScalar(1));
                    rotation = new THREE.Quaternion().copy(camera.quaternion);
                }
                
                // Create model entity
                const model = document.createElement('a-entity');
                model.setAttribute('gltf-model', `url(${modelUrl})`);
                model.setAttribute('scale', '0.5 0.5 0.5');
                model.setAttribute('position', position);
                model.setAttribute('rotation', new THREE.Euler().setFromQuaternion(rotation));
                model.setAttribute('animation', {
                    property: 'scale',
                    to: '1 1 1',
                    dur: 500,
                    easing: 'easeOutElastic'
                });
                
                dynamicContent.appendChild(model);
                modelPlaced = true;
                reticle.style.display = 'none';
                
                // Add click interaction
                model.addEventListener('click', () => {
                    model.setAttribute('animation', {
                        property: 'rotation',
                        to: '0 360 0',
                        dur: 2000,
                        loop: true
                    });
                });
            }
            
            // Event listeners
            startButton.addEventListener('click', initARSession);
            placeButton.addEventListener('click', placeModel);
            toggleMeshButton.addEventListener('click', toggleSurfaceMesh);
            
            // Handle screen taps
            document.addEventListener('click', (e) => {
                if (!modelPlaced && hasSurfaceDetection && e.target === document.body) {
                    placeModel();
                }
            });
            
            // Check for WebXR support
            if (navigator.xr) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        startButton.style.display = 'block';
                        loading.textContent = "Ready to start AR experience";
                    } else {
                        loading.textContent = "AR not supported on your device";
                    }
                });
            } else {
                loading.textContent = "WebXR not supported in your browser";
            }
        });
    </script>
</body>
</html>
