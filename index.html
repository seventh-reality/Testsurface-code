<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebXR AR with Surface Tracking</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/XRControllerModelFactory.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #ar-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui { position: absolute; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 10px; border-radius: 5px; z-index: 1; }
        #loading, #error { margin-bottom: 10px; }
        #start-button, #permission-button { padding: 10px 20px; border: none; background-color: #007bff; color: white; border-radius: 5px; cursor: pointer; font-size: 16px; display: block; margin-top: 10px; }
        #start-button:hover, #permission-button:hover { background-color: #0056b3; }
    </style>
</head>
<body>
    <div id="ar-container"></div>

    <div id="ui">
        <div id="loading">
            <div id="progress">Initializing...</div>
        </div>
        <div id="error" style="display: none; color: red;"></div>
        <button id="start-button" style="display: none;">Start AR Experience</button>
        <button id="permission-button" style="display: none;">Grant Camera Permission</button>
    </div>

    <script>
        // Configuration
        const config = {
            modelUrl: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf',
            modelScale: 0.3,
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
        };

        // Global variables
        let scene, camera, renderer, xrSession;
        let hitTestSource = null, model = null;
        let modelPlaced = false;
        let reticleVisible = false;
        let gltfLoader;
        let cameraPermissionGranted = false;
        let xrRefSpace = null;
        let controller = null;
        let controllerGrip = null;
        let resourcesLoaded = false;
        let arSupported = false;
        let reticle;

        // Initialize the app
        init();

        function init() {
            setupScene();

            const loadingManager = new THREE.LoadingManager(
                () => {
                    resourcesLoaded = true;
                    document.getElementById('progress').textContent = 'Ready to start AR';
                    updateStartButtonState();
                },
                (url, itemsLoaded, itemsTotal) => {
                    const progress = Math.round(itemsLoaded / itemsTotal * 100);
                    document.getElementById('progress').textContent = `Loading ${progress}%`;
                },
                (url) => {
                    document.getElementById('progress').textContent = `Error loading ${url}`;
                    showError(`Error loading resource: ${url}`);
                }
            );

            gltfLoader = new THREE.GLTFLoader(loadingManager);

            setupEventListeners();
            checkARSupport();
        }

        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;

            const container = document.getElementById('ar-container');
            container.appendChild(renderer.domElement);

            // Improved lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 5, 5);
            scene.add(directionalLight);

            // Reticle for visualization
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.8, transparent: true });
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupEventListeners() {
            document.getElementById('start-button').addEventListener('click', startAR);
            document.getElementById('permission-button').addEventListener('click', requestCameraPermission);
        }

        function checkARSupport() {
            document.getElementById('progress').textContent = 'Checking AR support...';

            if (!navigator.xr) {
                showError("WebXR not supported on this device");
                document.getElementById('start-button').style.display = 'none';
                return;
            }

            navigator.xr.isSessionSupported('immersive-ar')
                .then(supported => {
                    arSupported = supported;
                    if (!supported) {
                        showError("AR not supported on this device");
                        document.getElementById('start-button').style.display = 'none';
                    } else {
                        document.getElementById('progress').textContent = 'AR supported, loading model...';
                        loadModel();
                        checkCameraPermissions();
                    }
                })
                .catch(err => {
                    console.error("WebXR check failed:", err);
                    showError("Error checking AR support");
                });
        }

        async function checkCameraPermissions() {
            if (!navigator.permissions) {
                // If Permissions API isn't available, we'll try to get permission on start
                updateStartButtonState();
                return;
            }

            try {
                const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                cameraPermissionGranted = permissionStatus.state === 'granted';
                if (!cameraPermissionGranted) {
                    document.getElementById('permission-button').style.display = 'block';
                    document.getElementById('progress').textContent = 'Camera permission required';
                }
                updateStartButtonState();

                permissionStatus.onchange = () => {
                    cameraPermissionGranted = permissionStatus.state === 'granted';
                    updateStartButtonState();
                    if (cameraPermissionGranted) {
                        document.getElementById('permission-button').style.display = 'none';
                        document.getElementById('progress').textContent = 'Camera permission granted';
                    } else {
                        document.getElementById('permission-button').style.display = 'block';
                        document.getElementById('progress').textContent = 'Camera permission required';
                    }
                };
            } catch (err) {
                console.log("Camera permission check error:", err);
                // Fallback to trying to get permission when starting AR
                updateStartButtonState();
                document.getElementById('permission-button').style.display = 'block';
                document.getElementById('progress').textContent = 'Camera permission check failed, will request on start.';
            }
        }

        function loadModel() {
            gltfLoader.load(config.modelUrl, gltf => {
                model = gltf.scene;
                model.scale.set(config.modelScale, config.modelScale, config.modelScale);
                model.visible = false;
                scene.add(model);
                updateStartButtonState();
            }, undefined, error => {
                console.error("Error loading model:", error);
                showError("Error loading 3D model");
            });
        }

        function updateStartButtonState() {
            if (arSupported && resourcesLoaded && cameraPermissionGranted) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('start-button').style.display = 'block';
            } else if (arSupported && resourcesLoaded && !cameraPermissionGranted && !navigator.permissions) {
                // If no permissions API, still show start button to try and get permission
                document.getElementById('loading').style.display = 'none';
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('progress').textContent = 'Camera permission might be needed.';
            }
        }

        function showError(message) {
            const errorElement = document.getElementById('error');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        async function requestCameraPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop());
                cameraPermissionGranted = true;
                document.getElementById('permission-button').style.display = 'none';
                document.getElementById('progress').textContent = 'Camera permission granted';
                updateStartButtonState();
            } catch (err) {
                console.error("Camera permission error:", err);
                showError("Failed to get camera permission");
            }
        }

        async function startAR() {
            if (!navigator.xr) {
                showError("WebXR not available");
                return;
            }

            if (!cameraPermissionGranted && navigator.permissions) {
                const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                if (permissionStatus.state !== 'granted') {
                    document.getElementById('permission-button').style.display = 'block';
                    document.getElementById('progress').textContent = 'Camera permission required. Please grant access.';
                    return;
                } else {
                    cameraPermissionGranted = true;
                }
            } else if (!cameraPermissionGranted && !navigator.permissions) {
                // Try to get user media if permissions API is not available
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    stream.getTracks().forEach(track => track.stop());
                    cameraPermissionGranted = true;
                } catch (err) {
                    console.error("Camera permission error:", err);
                    showError("Failed to get camera permission.");
                    return;
                }
            }

            const sessionInit = {
                optionalFeatures: config.optionalFeatures,
                requiredFeatures: config.requiredFeatures,
                domOverlay: config.domOverlay
            };

            navigator.xr.requestSession('immersive-ar', sessionInit)
                .then(onSessionStarted)
                .catch(err => {
                    console.error("Session creation error:", err);
                    if (err.name === 'SecurityError') {
                        showError("Camera permission required. Please grant camera access.");
                        document.getElementById('permission-button').style.display = 'block';
                    } else {
                        showError("Failed to start AR session: " + err.message);
                    }
                });
        }

        function onSessionStarted(session) {
            xrSession = session;
            document.getElementById('ui').style.display = 'none';

            session.addEventListener('end', onSessionEnded);

            renderer.xr.setSession(session)
                .then(() => {
                    setupARSession();
                })
                .catch(err => {
                    console.error("Error setting XR session:", err);
                    showError("Error starting AR session");
                    session.end();
                });

            // Start the render loop
            renderer.setAnimationLoop(onXRFrame);
        }

        function setupARSession() {
            xrSession.requestReferenceSpace('local').then(refSpace => {
                xrRefSpace = refSpace;

                xrSession.requestReferenceSpace('viewer').then(viewerRefSpace => {
                    xrSession.requestHitTestSource({ space: viewerRefSpace }).then(source => {
                        hitTestSource = source;
                    }).catch(err => {
                        console.error("Hit test source error:", err);
                        showError("Failed to create hit test source.");
                    });
                }).catch(err => {
                    console.error("Viewer reference space error:", err);
                    showError("Failed to create viewer reference space.");
                });

                // Set up controller if available
                if (xrSession.inputSources && xrSession.inputSources.length > 0) {
                    setupController(xrSession.inputSources[0]);
                }
                xrSession.addEventListener('inputsourceschange', onInputSourcesChange);

            }).catch(err => {
                console.error("Reference space error:", err);
                showError("Failed to create local reference space.");
            });
        }

        function onInputSourcesChange(event) {
            if (event.added && event.added.length > 0) {
                setupController(event.added[0]);
            }
            if (event.removed && event.removed.length > 0 && controller) {
                // Basic cleanup, more robust handling might be needed
                scene.remove(controller);
                scene.remove(controllerGrip);
                controller = null;
                controllerGrip = null;
            }
        }

        function setupController(inputSource) {
            const controllerModelFactory = new XRControllerModelFactory();

            controller = renderer.xr.getController(0);
            controller.addEventListener('selectstart', onSelectStart);
            controller.addEventListener('selectend', onSelectEnd);
            scene.add(controller);

            controllerGrip = renderer.xr.getControllerGrip(0);
            controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
            scene.add(controllerGrip);
        }

        function onSelectStart() {
            if (model && reticleVisible && !modelPlaced) {
                modelPlaced = true;
                model.position.copy(reticle.position);
                model.quaternion.copy(reticle.quaternion);
                model.visible = true;
            }
        }

        function onSelectEnd() {
            // Handle select end if needed
        }

        function onXRFrame(time, frame) {
            if (!xrSession || !frame) return;

            const pose = frame.getViewerPose(xrRefSpace);

            if (pose && hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const hitPose = hit.getPose(xrRefSpace);

                    if (hitPose) {
                        reticle.visible = true;
                        reticle.matrix.fromArray(hitPose.transform.matrix);
                        reticleVisible = true;
                    } else {
                        reticle.visible = false;
                        reticleVisible = false;
                    }

                } else {
                    reticle.visible = false;
                    reticleVisible = false;
                }
            }

            renderer.render(scene, camera);
        }

        function onSessionEnded() {
            if (xrSession) {
                xrSession.removeEventListener('end', onSessionEnded);
                xrSession.removeEventListener('inputsourceschange', onInputSourcesChange);
                xrSession = null;
            }

            document.getElementById('ui').style.display = 'block';
            renderer.setAnimationLoop(null);

            // Reset model placement
            modelPlaced = false;
            if (model) {
                model.visible = false;
                model.position.set(0, 0, 0);
            }
            if (reticle) {
                reticle.visible = false;
            }
        }
    </script>
</body>
</html>
