<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebXR AR with Fixed Loading</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/XRControllerModelFactory.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none; 
            background-color: #000;
        }
        #ar-container { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
        }
        #start-button {
            position: fixed; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%);
            padding: 15px 30px; 
            font-size: 18px; 
            background: #007BFF; 
            color: white; 
            border: none;
            border-radius: 10px; 
            cursor: pointer; 
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        #reticle {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 5;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        #hint {
            position: fixed;
            bottom: 80px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 5;
            display: none;
        }
        #permission-button {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            background: #FF5722;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            z-index: 15;
            display: none;
        }
        #error-message {
            position: fixed;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: red;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 30;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ar-container"></div>
    <div id="reticle"></div>
    <div id="hint">Point at a surface and tap to place object</div>
    <button id="start-button">Start AR</button>
    <button id="permission-button">Allow Camera Access</button>
    <div id="loading">
        <h2>Loading AR Experience</h2>
        <p id="progress">Initializing...</p>
    </div>
    <div id="error-message"></div>

    <script>
        // Configuration
        const config = {
            modelUrl: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf',
            modelScale: 0.3,
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body },
            cameraConfig: {
                facingMode: 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        };

        // Global variables
        let scene, camera, renderer, xrSession;
        let hitTestSource = null, model = null;
        let modelPlaced = false;
        let reticleVisible = false;
        let loadingManager = new THREE.LoadingManager();
        let gltfLoader = new THREE.GLTFLoader(loadingManager);
        let cameraPermissionGranted = false;
        let currentStream = null;
        let xrRefSpace = null;
        let controller = null;
        let controllerGrip = null;
        let hitTestSourceRequested = false;
        let resourcesLoaded = false;
        let arSupported = false;

        // Initialize the app
        init();

        function init() {
            setupScene();
            setupLoadingManager();
            setupEventListeners();
            checkARSupport();
        }

        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('ar-container').appendChild(renderer.domElement);

            // Improved lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 5, 5);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize);
        }

        function setupLoadingManager() {
            loadingManager.onStart = () => {
                document.getElementById('progress').textContent = 'Loading resources...';
            };

            loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                const progress = Math.round(itemsLoaded / itemsTotal * 100);
                document.getElementById('progress').textContent = `Loading ${progress}%`;
            };

            loadingManager.onLoad = () => {
                resourcesLoaded = true;
                document.getElementById('progress').textContent = 'Ready to start AR';
                updateStartButtonState();
            };

            loadingManager.onError = (url) => {
                showError(`Error loading ${url}`);
                document.getElementById('progress').textContent = `Error loading resources`;
            };
        }

        function setupEventListeners() {
            document.getElementById('start-button').addEventListener('click', startAR);
            document.getElementById('permission-button').addEventListener('click', requestCameraPermission);
        }

        function checkARSupport() {
            document.getElementById('progress').textContent = 'Checking AR support...';
            
            if (!navigator.xr) {
                showError("WebXR not supported on this device");
                document.getElementById('start-button').style.display = 'none';
                return;
            }

            navigator.xr.isSessionSupported('immersive-ar')
                .then(supported => {
                    arSupported = supported;
                    if (!supported) {
                        showError("AR not supported on this device");
                        document.getElementById('start-button').style.display = 'none';
                    } else {
                        document.getElementById('progress').textContent = 'AR supported, loading model...';
                        loadModel();
                        checkCameraPermissions();
                    }
                })
                .catch(err => {
                    console.error("WebXR check failed:", err);
                    showError("Error checking AR support");
                });
        }

        function checkCameraPermissions() {
            navigator.permissions.query({ name: 'camera' })
                .then(permissionStatus => {
                    if (permissionStatus.state === 'granted') {
                        cameraPermissionGranted = true;
                    }
                    updateStartButtonState();
                })
                .catch(err => {
                    console.log("Camera permission API not available, proceeding...");
                    // Proceed without permission status
                });
        }

        function loadModel() {
            gltfLoader.load(config.modelUrl, gltf => {
                model = gltf.scene;
                model.scale.set(config.modelScale, config.modelScale, config.modelScale);
                model.visible = false;
                scene.add(model);
                updateStartButtonState();
            }, undefined, error => {
                console.error("Error loading model:", error);
                showError("Error loading 3D model");
            });
        }

        function updateStartButtonState() {
            if (arSupported && resourcesLoaded) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('start-button').style.display = 'block';
            }
        }

        async function startAR() {
            try {
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('progress').textContent = 'Starting AR session...';
                document.getElementById('start-button').style.display = 'none';
                document.getElementById('hint').style.display = 'block';

                // Request AR session
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: config.requiredFeatures,
                    optionalFeatures: config.optionalFeatures,
                    domOverlay: config.domOverlay
                });

                renderer.xr.setSession(xrSession);
                
                // Set up reference space
                xrRefSpace = await xrSession.requestReferenceSpace('local');
                
                // Set up controller
                setupXRController();
                
                // Event listeners
                xrSession.addEventListener('end', onSessionEnd);

                // Start render loop
                renderer.setAnimationLoop((timestamp, frame) => {
                    renderAR(frame);
                });

                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error("Failed to start AR session:", error);
                showError("Failed to start AR session: " + error.message);
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('loading').style.display = 'none';
                
                if (error.message.includes('camera')) {
                    document.getElementById('permission-button').style.display = 'block';
                }
            }
        }

        function setupXRController() {
            // Create a controller
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Optional: Add controller model
            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip = renderer.xr.getControllerGrip(0);
            controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
            scene.add(controllerGrip);
        }

        async function requestHitTestSource() {
            if (hitTestSourceRequested) return;
            
            try {
                const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                hitTestSource = await xrSession.requestHitTestSource({
                    space: viewerSpace,
                    entityTypes: ['plane', 'mesh']
                });
                hitTestSourceRequested = true;
            } catch (error) {
                console.error("Failed to create hit test source:", error);
            }
        }

        function onSelect() {
            if (!model || !hitTestSource) return;
            
            if (reticleVisible) {
                // Place or move the model
                const reticle = document.getElementById('reticle');
                const screenX = parseFloat(reticle.style.left) / window.innerWidth * 2 - 1;
                const screenY = -(parseFloat(reticle.style.top) / window.innerHeight * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(screenX, screenY), camera);
                
                const intersects = raycaster.intersectObjects(scene.children);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    model.position.copy(point);
                    model.visible = true;
                    modelPlaced = true;
                    document.getElementById('hint').textContent = 'Tap again to move object';
                }
            }
        }

        function renderAR(frame) {
            if (!frame) return;
            
            // Request hit test source on first frame
            if (!hitTestSourceRequested) {
                requestHitTestSource();
            }
            
            // Update reticle position if we have a hit test source
            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const pose = hit.getPose(xrRefSpace);
                    
                    // Show reticle
                    document.getElementById('reticle').style.display = 'block';
                    const pos = pose.transform.position;
                    const clipPos = new THREE.Vector3(pos.x, pos.y, pos.z).project(camera);
                    
                    const x = (clipPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (clipPos.y * -0.5 + 0.5) * window.innerHeight;
                    document.getElementById('reticle').style.left = `${x}px`;
                    document.getElementById('reticle').style.top = `${y}px`;
                    
                    reticleVisible = true;
                } else {
                    document.getElementById('reticle').style.display = 'none';
                    reticleVisible = false;
                }
            }

            renderer.render(scene, camera);
        }

        function onSessionEnd() {
            if (xrSession) {
                xrSession.removeEventListener('end', onSessionEnd);
            }
            
            renderer.setAnimationLoop(null);
            xrSession = null;
            hitTestSource = null;
            hitTestSourceRequested = false;
            modelPlaced = false;
            
            if (model) {
                model.visible = false;
            }
            
            if (controller) {
                controller.removeEventListener('select', onSelect);
                scene.remove(controller);
                if (controllerGrip) {
                    scene.remove(controllerGrip);
                }
                controller = null;
                controllerGrip = null;
            }
            
            document.getElementById('start-button').style.display = 'block';
            document.getElementById('hint').style.display = 'none';
            document.getElementById('reticle').style.display = 'none';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-message').style.display = 'block';
            setTimeout(() => {
                document.getElementById('error-message').style.display = 'none';
            }, 5000);
        }

        function requestCameraPermission() {
            document.getElementById('progress').textContent = 'Requesting camera access...';
            document.getElementById('permission-button').style.display = 'none';
            
            navigator.mediaDevices.getUserMedia({ video: config.cameraConfig })
                .then(stream => {
                    currentStream = stream;
                    stopStream(stream);
                    cameraPermissionGranted = true;
                    document.getElementById('progress').textContent = 'Camera access granted';
                    startAR();
                })
                .catch(err => {
                    console.error("Camera permission denied:", err);
                    showError('Camera access denied. Please allow camera access in your browser settings.');
                    document.getElementById('permission-button').style.display = 'block';
                });
        }

        function stopStream(stream) {
            if (!stream) return;
            stream.getTracks().forEach(track => {
                track.stop();
            });
        }
    </script>
</body>
</html>
