<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Model AR Viewer with SLAM</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        #ar-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #loading p {
            margin-top: 20px;
            font-family: Arial, sans-serif;
        }
        #model-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        button:hover {
            background: rgba(255, 255, 255, 1);
        }
        #error {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="ar-container"></div>
    
    <div id="loading">
        <p>Loading AR experience...</p>
        <p id="progress-text">Initializing</p>
    </div>
    
    <div id="error"></div>
    
    <div id="model-controls" style="display: none;">
        <button id="place-model">Place Model</button>
        <button id="reset-model">Reset</button>
    </div>

    <!-- Import required libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ar-js-org/ar.js@3.4.0/dist/ar.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, controller, model, arToolkitSource, arToolkitContext;
        let modelPlaced = false;
        let modelAnchor = null;
        
        // Configuration
        const config = {
            modelUrl: 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@2.0/~/2.0/Duck/glTF/Duck.gltf',
            scale: 0.5,
            markerPatternURL: 'https://arjs-cors-proxy.herokuapp.com/https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/data/hiro.patt',
            detectionMode: 'mono_and_matrix',
            matrixCodeType: '3x3',
            cameraParametersURL: 'https://arjs-cors-proxy.herokuapp.com/https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/data/camera_para.dat'
        };
        
        // Initialize the application
        init();
        
        function init() {
            // Check for WebXR and AR support
            if (!checkARSupport()) {
                showError("AR is not supported on your device or browser. Try Chrome on Android or Safari on iOS.");
                return;
            }
            
            // Initialize Three.js scene
            initScene();
            
            // Initialize AR.js
            initAR();
            
            // Load the 3D model
            loadModel();
            
            // Set up event listeners
            setupEventListeners();
            
            // Start the render loop
            animate();
        }
        
        function checkARSupport() {
            // Check for WebXR and AR.js support
            return (navigator.xr && 
                   (navigator.xr.isSessionSupported('immersive-ar') || 
                    window.WebXRPolyfill)) && 
                   window.ARController;
        }
        
        function initScene() {
            // Create Three.js scene
            scene = new THREE.Scene();
            
            // Create camera (will be updated by AR.js)
            camera = new THREE.Camera();
            scene.add(camera);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            
            // Add renderer to DOM
            document.getElementById('ar-container').appendChild(renderer.domElement);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
        }
        
        function initAR() {
            // AR.js source (handles camera feed)
            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam',
                sourceWidth: window.innerWidth,
                sourceHeight: window.innerHeight,
                displayWidth: window.innerWidth,
                displayHeight: window.innerHeight
            });
            
            // Initialize AR.js source
            arToolkitSource.init(function onReady() {
                // Hide loading screen when camera is ready
                document.getElementById('loading').style.display = 'none';
                document.getElementById('model-controls').style.display = 'flex';
                
                // Handle resize
                setTimeout(() => {
                    onResize();
                }, 2000);
            });
            
            // AR.js context (handles marker detection)
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: config.cameraParametersURL,
                detectionMode: config.detectionMode,
                matrixCodeType: config.matrixCodeType,
                maxDetectionRate: 60,
                canvasWidth: window.innerWidth,
                canvasHeight: window.innerHeight
            });
            
            // Initialize AR.js context
            arToolkitContext.init(function onCompleted() {
                // Copy projection matrix to camera when initialized
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            });
            
            // Create AR controller
            controller = new THREE.ARController(arToolkitContext, {
                onResize: onResize
            });
            
            // Handle window resize
            window.addEventListener('resize', onResize);
        }
        
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            
            // Optional: Use DRACO loader for compressed models
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/libs/draco/');
            loader.setDRACOLoader(dracoLoader);
            
            document.getElementById('progress-text').textContent = 'Loading 3D model...';
            
            loader.load(
                config.modelUrl,
                function (gltf) {
                    model = gltf.scene;
                    model.scale.set(config.scale, config.scale, config.scale);
                    model.visible = false;
                    
                    document.getElementById('progress-text').textContent = 'Model loaded. Ready for AR!';
                    
                    // Add model to scene when placed
                    document.getElementById('place-model').addEventListener('click', function() {
                        if (!modelPlaced) {
                            placeModelInWorld();
                        }
                    });
                },
                function (xhr) {
                    // Progress callback
                    const percentComplete = (xhr.loaded / xhr.total) * 100;
                    document.getElementById('progress-text').textContent = 
                        `Loading model: ${Math.round(percentComplete)}%`;
                },
                function (error) {
                    console.error('Error loading model:', error);
                    showError("Failed to load 3D model. Please check your connection and try again.");
                }
            );
        }
        
        function placeModelInWorld() {
            if (modelPlaced) return;
            
            // Create an anchor at the current camera position
            const position = new THREE.Vector3();
            camera.getWorldPosition(position);
            
            // Offset the model slightly in front of the camera
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            position.add(direction.multiplyScalar(1));
            
            // Create a group to hold the model (acts as an anchor)
            modelAnchor = new THREE.Group();
            modelAnchor.position.copy(position);
            
            // Look at the camera (optional)
            modelAnchor.lookAt(camera.position);
            
            // Add model to the anchor
            modelAnchor.add(model);
            model.visible = true;
            
            // Add anchor to scene
            scene.add(modelAnchor);
            
            modelPlaced = true;
            
            // Update controls UI
            document.getElementById('place-model').textContent = 'Move Model';
        }
        
        function resetModel() {
            if (modelAnchor) {
                scene.remove(modelAnchor);
                modelAnchor = null;
            }
            modelPlaced = false;
            document.getElementById('place-model').textContent = 'Place Model';
        }
        
        function setupEventListeners() {
            // Model placement controls
            document.getElementById('place-model').addEventListener('click', function() {
                if (modelPlaced) {
                    // If model is already placed, move it
                    resetModel();
                    placeModelInWorld();
                } else {
                    placeModelInWorld();
                }
            });
            
            document.getElementById('reset-model').addEventListener('click', resetModel);
            
            // Handle touch events for model interaction
            let touchStartX, touchStartY;
            let isDragging = false;
            
            document.addEventListener('touchstart', function(e) {
                if (!modelPlaced || e.touches.length !== 1) return;
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                isDragging = true;
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchmove', function(e) {
                if (!isDragging || !modelAnchor || e.touches.length !== 1) return;
                
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                
                // Calculate movement delta
                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;
                
                // Update model position based on touch movement
                const movementScale = 0.01;
                modelAnchor.position.x += deltaX * movementScale;
                modelAnchor.position.y -= deltaY * movementScale;
                
                touchStartX = touchX;
                touchStartY = touchY;
                
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchend', function() {
                isDragging = false;
            });
        }
        
        function onResize() {
            if (arToolkitSource) {
                arToolkitSource.onResizeElement();
                arToolkitSource.copyElementSizeTo(renderer.domElement);
            }
            
            if (arToolkitContext) {
                arToolkitContext.arController.setProjectionMatrix();
            }
            
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        function showError(message) {
            const errorElement = document.getElementById('error');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            
            document.getElementById('loading').style.display = 'none';
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update AR.js
            if (arToolkitSource && arToolkitSource.ready) {
                arToolkitContext.update(arToolkitSource.domElement);
                
                // Update scene with camera position
                if (controller && controller.visible) {
                    scene.visible = camera.visible;
                }
            }
            
            // Rotate model if placed
            if (modelPlaced && modelAnchor) {
                modelAnchor.rotation.y += 0.005;
            }
            
            // Render scene
            renderer.clear();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
