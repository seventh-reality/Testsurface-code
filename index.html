<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <title>AR Model Interaction</title>
  <!-- A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  <!-- AR.js for fallback -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Hammer.js for gestures -->
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      font-family: -apple-system, Arial, sans-serif;
    }
    #ar-container {
      position: fixed;  /* Changed from absolute to fixed */
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 100;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 2px black;
      z-index: 10;
      pointer-events: none;
    }
    #start-button {
      padding: 12px 24px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 20px;
    }
    .unsupported {
      color: #ff4444;
      margin-top: 20px;
    }
    #surface-indicator {
      position: fixed;
      width: 40px;
      height: 40px;
      border: 2px solid rgba(255,255,255,0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 20;
      display: none;
    }
    #gesture-help {
      position: fixed;
      bottom: 60px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      z-index: 15;
      display: none;
    }
    /* Ensure canvas fills container */
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <div id="loading">
    <h1>AR Model Interaction</h1>
    <p>Initializing AR environment...</p>
    <div id="support-message"></div>
    <button id="start-button">Start AR Experience</button>
  </div>

  <div id="info">Move device to detect surfaces. Tap to place the model.</div>
  <div id="gesture-help">Use one finger to move, two fingers to rotate/scale</div>
  <div id="surface-indicator"></div>
  
  <div id="ar-container"></div>

  <script>
    // Configuration
    const config = {
      modelUrl: 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models/2.0/Duck/glTF/Duck.gltf',
      debug: true,
      initialScale: 0.5,
      minScale: 0.1,
      maxScale: 2.0,
      stabilityThreshold: 0.05
    };

    // Global variables
    let scene, camera, renderer;
    let model = null;
    let reticle = null;
    let arjsScene = null;
    let isModelPlaced = false;
    let currentScale = config.initialScale;
    let lastPosition = new THREE.Vector3();
    let hammerManager = null;
    let initialDistance = 0;
    let initialScale = 1;
    let initialAngle = 0;
    let initialRotation = 0;

    // Check for WebXR support
    async function checkXRSupport() {
      if (!navigator.xr) return false;
      try {
        return await navigator.xr.isSessionSupported('immersive-ar');
      } catch (e) {
        console.error("XR support check failed:", e);
        return false;
      }
    }

    // Check camera permissions
    async function checkCameraPermissions() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        stream.getTracks().forEach(track => track.stop());
        return true;
      } catch (e) {
        console.error("Camera permission denied:", e);
        return false;
      }
    }

    // Initialize WebXR mode
    async function initWebXR() {
      try {
        const hasPermission = await checkCameraPermissions();
        if (!hasPermission) {
          showCameraError();
          return;
        }

        // Create Three.js scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        
        renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true,
          powerPreference: "high-performance"
        });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        renderer.xr.enabled = true;
        document.getElementById('ar-container').appendChild(renderer.domElement);
        
        // Lighting
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0.5, 1, 0.25);
        scene.add(directionalLight);
        
        // Reticle for surface indication
        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
        
        // Load model
        const loader = new THREE.GLTFLoader();
        try {
          const gltf = await loader.loadAsync(config.modelUrl);
          model = gltf.scene;
          model.scale.set(config.initialScale, config.initialScale, config.initialScale);
          model.visible = false; // Start hidden until placed
          scene.add(model);
        } catch (e) {
          console.error("Failed to load model:", e);
          model = new THREE.Mesh(
            new THREE.BoxGeometry(config.initialScale, config.initialScale, config.initialScale),
            new THREE.MeshStandardMaterial({ color: 0x00ff00 })
          );
          model.visible = false;
          scene.add(model);
        }
        
        // Start AR session
        const session = await navigator.xr.requestSession('immersive-ar');
        await renderer.xr.setSession(session);
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('gesture-help').style.display = 'block';
        document.getElementById('surface-indicator').style.display = 'block';
        
        // Set up controller for placement
        const controller = renderer.xr.getController(0);
        controller.addEventListener('select', placeModel);
        scene.add(controller);
        
        // Set up gesture controls after model is placed
        setupGestureControls();
        
        // Start animation loop
        renderer.setAnimationLoop(render);
      } catch (e) {
        console.error("WebXR initialization failed:", e);
        fallbackToARJS();
      }
    }

    // Initialize AR.js fallback mode
    async function initARJS() {
      try {
        const hasPermission = await checkCameraPermissions();
        if (!hasPermission) {
          showCameraError();
          return;
        }

        document.getElementById('ar-container').innerHTML = `
          <a-scene 
            vr-mode-ui="enabled: false"
            arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
            renderer="logarithmicDepthBuffer: true; precision: medium;"
            embedded
            cursor="rayOrigin: mouse; fuse: false"
            raycaster="objects: .clickable">
            
            <a-camera gps-camera rotation-reader></a-camera>
            
            <a-entity geometry="primitive: plane; width: 100; height: 100" 
                     material="visible: false; shader: flat"
                     rotation="-90 0 0" class="clickable surface-plane">
            </a-entity>
            
            <a-entity id="model" gltf-model="${config.modelUrl}" 
                     scale="${config.initialScale} ${config.initialScale} ${config.initialScale}" 
                     visible="false">
            </a-entity>
          </a-scene>
        `;
        
        arjsScene = document.querySelector('a-scene');
        const modelEl = document.getElementById('model');
        
        arjsScene.addEventListener('loaded', () => {
          document.getElementById('loading').style.display = 'none';
          document.getElementById('gesture-help').style.display = 'block';
          
          // Place model on surface click
          arjsScene.addEventListener('click', (e) => {
            if (!isModelPlaced && e.detail.intersection && 
                e.detail.intersection.object.el.classList.contains('surface-plane')) {
              placeModelARJS(e.detail.intersection.point);
            }
          });
          
          // Set up gesture controls after model is placed
          setupARJSGestureControls(modelEl);
        });
      } catch (e) {
        console.error("AR.js initialization failed:", e);
        document.getElementById('support-message').innerHTML = 
          '<p class="unsupported">Failed to initialize AR</p>';
      }
    }

    // Place model in WebXR mode
    function placeModel() {
      if (!isModelPlaced && reticle.visible) {
        model.position.setFromMatrixPosition(reticle.matrix);
        model.quaternion.setFromRotationMatrix(reticle.matrix);
        model.visible = true;
        isModelPlaced = true;
        
        // Change reticle color to indicate placement
        reticle.material.color.setHex(0x00ff00);
      }
    }

    // Place model in AR.js mode
    function placeModelARJS(position) {
      const modelEl = document.getElementById('model');
      modelEl.setAttribute('visible', 'true');
      modelEl.setAttribute('position', position);
      isModelPlaced = true;
    }

    // Set up gesture controls for WebXR
    function setupGestureControls() {
      const canvas = renderer.domElement;
      hammerManager = new Hammer.Manager(canvas);
      
      // Single finger pan to move model
      const pan = new Hammer.Pan({ threshold: 5 });
      hammerManager.add(pan);
      
      // Two finger pinch to scale model
      const pinch = new Hammer.Pinch({ threshold: 0.1 });
      hammerManager.add(pinch);
      
      // Two finger rotate to rotate model
      const rotate = new Hammer.Rotate({ threshold: 0.1 });
      hammerManager.add(rotate);
      
      hammerManager.on("panstart", (e) => {
        if (isModelPlaced) {
          lastPosition.copy(model.position);
        }
      });
      
      hammerManager.on("pan", (e) => {
        if (isModelPlaced && e.pointers.length === 1) {
          // Convert screen coordinates to world coordinates
          const vector = new THREE.Vector3(
            (e.center.x / window.innerWidth) * 2 - 1,
            -(e.center.y / window.innerHeight) * 2 + 1,
            0.5
          );
          vector.unproject(camera);
          
          const direction = vector.sub(camera.position).normalize();
          const distance = -camera.position.y / direction.y;
          const position = camera.position.clone().add(direction.multiplyScalar(distance));
          
          model.position.copy(position);
        }
      });
      
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          initialScale = currentScale;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          currentScale = Math.min(config.maxScale, 
                                Math.max(config.minScale, initialScale * e.scale));
          model.scale.set(currentScale, currentScale, currentScale);
        }
      });
      
      hammerManager.on("rotatestart", (e) => {
        if (isModelPlaced) {
          initialRotation = model.rotation.y;
        }
      });
      
      hammerManager.on("rotate", (e) => {
        if (isModelPlaced) {
          model.rotation.y = initialRotation + e.rotation * (Math.PI / 180);
        }
      });
    }

    // Set up gesture controls for AR.js
    function setupARJSGestureControls(modelEl) {
      const container = document.getElementById('ar-container');
      hammerManager = new Hammer.Manager(container);
      
      // Single finger pan to move model
      const pan = new Hammer.Pan({ threshold: 5 });
      hammerManager.add(pan);
      
      // Two finger pinch to scale model
      const pinch = new Hammer.Pinch({ threshold: 0.1 });
      hammerManager.add(pinch);
      
      // Two finger rotate to rotate model
      const rotate = new Hammer.Rotate({ threshold: 0.1 });
      hammerManager.add(rotate);
      
      let startPosition = null;
      let startScale = config.initialScale;
      let startRotation = 0;
      
      hammerManager.on("panstart", (e) => {
        if (isModelPlaced) {
          const pos = modelEl.getAttribute('position');
          startPosition = new THREE.Vector3(pos.x, pos.y, pos.z);
        }
      });
      
      hammerManager.on("pan", (e) => {
        if (isModelPlaced && e.pointers.length === 1 && startPosition) {
          // Convert pan movement to model position change
          const camera = arjsScene.camera;
          const movementX = e.deltaX / window.innerWidth * 2;
          const movementY = -e.deltaY / window.innerHeight * 2;
          
          // Create a vector in camera space
          const movement = new THREE.Vector3(movementX, movementY, 0);
          
          // Transform to world space
          movement.applyQuaternion(camera.quaternion);
          
          // Update model position
          const newPosition = new THREE.Vector3(
            startPosition.x + movement.x,
            startPosition.y + movement.y,
            startPosition.z + movement.z
          );
          
          modelEl.setAttribute('position', newPosition);
        }
      });
      
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          startScale = modelEl.getAttribute('scale').x;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          const newScale = Math.min(config.maxScale, 
                                  Math.max(config.minScale, startScale * e.scale));
          modelEl.setAttribute('scale', {
            x: newScale,
            y: newScale,
            z: newScale
          });
        }
      });
      
      hammerManager.on("rotatestart", (e) => {
        if (isModelPlaced) {
          startRotation = modelEl.getAttribute('rotation').y || 0;
        }
      });
      
      hammerManager.on("rotate", (e) => {
        if (isModelPlaced) {
          const newRotation = startRotation + e.rotation;
          modelEl.setAttribute('rotation', {
            x: 0,
            y: newRotation,
            z: 0
          });
        }
      });
    }

    // WebXR render loop
    function render(timestamp, frame) {
      if (!frame) return;
      
      if (reticle && !isModelPlaced) {
        // Get hit test results for surface detection
        const hitTestResults = frame.getHitTestResultsForInputSource(frame.session.inputSources[0]);
        
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(renderer.xr.getReferenceSpace());
          
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
          
          // Update surface indicator position
          const position = new THREE.Vector3();
          position.setFromMatrixPosition(reticle.matrix);
          updateSurfaceIndicator(position);
        } else {
          reticle.visible = false;
          document.getElementById('surface-indicator').style.display = 'none';
        }
      }
      
      renderer.render(scene, camera);
    }

    // Update surface indicator position
    function updateSurfaceIndicator(position) {
      const indicator = document.getElementById('surface-indicator');
      if (!indicator) return;
      
      position.project(camera);
      
      const x = (position.x * 0.5 + 0.5) * window.innerWidth;
      const y = -(position.y * 0.5 - 0.5) * window.innerHeight;
      
      indicator.style.left = `${x - 20}px`;
      indicator.style.top = `${y - 20}px`;
      indicator.style.display = 'block';
    }

    // Show camera error message
    function showCameraError() {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('support-message').innerHTML = 
        '<p class="unsupported">Camera access was denied. Please enable camera permissions.</p>';
    }

    // Fallback to AR.js
    function fallbackToARJS() {
      initARJS();
    }

    // Handle window resize
    function onWindowResize() {
      if (camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight, false);
      }
    }

    // Start button event listener
    document.getElementById('start-button').addEventListener('click', async () => {
      const supported = await checkXRSupport();
      document.getElementById('start-button').disabled = true;
      
      if (supported) {
        initWebXR();
      } else {
        fallbackToARJS();
      }
    });

    // Initialize on load
    window.addEventListener('load', () => {
      window.addEventListener('resize', onWindowResize);
    });
  </script>
</body>
</html>
