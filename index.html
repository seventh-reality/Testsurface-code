<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Advanced AR Model Interaction</title>
  <!-- A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  <!-- AR.js for fallback -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Hammer.js for gestures -->
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
  <!-- WebXR Polyfill for broader device support -->
  <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      font-family: -apple-system, Arial, sans-serif;
    }
    #ar-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 100;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 2px black;
      z-index: 10;
      pointer-events: none;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      margin: 0 20px;
    }
    #start-button {
      padding: 12px 24px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 20px;
      transition: background 0.3s;
    }
    #start-button:hover {
      background: #45a049;
    }
    #start-button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .unsupported {
      color: #ff4444;
      margin-top: 20px;
      text-align: center;
      max-width: 80%;
    }
    #surface-indicator {
      position: fixed;
      width: 40px;
      height: 40px;
      border: 2px solid rgba(255,255,255,0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 20;
      display: none;
      transition: transform 0.1s;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    #gesture-help {
      position: fixed;
      bottom: 60px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 15;
      display: none;
      margin: 0 20px;
    }
    #stability-meter {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 100px;
      height: 10px;
      background: rgba(255,255,255,0.2);
      border-radius: 5px;
      overflow: hidden;
      z-index: 30;
      display: none;
    }
    #stability-progress {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #ff4444, #ffbb33, #00C851);
      transition: width 0.3s;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
    #debug-info {
      position: fixed;
      top: 40px;
      left: 20px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      font-size: 12px;
      z-index: 30;
      display: none;
    }
  </style>
</head>
<body>
  <div id="loading">
    <h1>Advanced AR Model Interaction</h1>
    <p>Initializing AR environment...</p>
    <div id="support-message"></div>
    <button id="start-button">Start AR Experience</button>
  </div>

  <div id="info">Move device slowly to detect surfaces. Tap to place the model.</div>
  <div id="gesture-help">Use one finger to move, two fingers to rotate/scale</div>
  <div id="surface-indicator"></div>
  <div id="stability-meter"><div id="stability-progress"></div></div>
  <div id="debug-info"></div>
  
  <div id="ar-container"></div>

  <script>
    // Enhanced Configuration
    const config = {
      modelUrl: 'all.glb',
      debug: true,
      initialScale: 1.0,
      minScale: 0.1,
      maxScale: 2.0,
      stabilityThreshold: 0.05,
      modelUnits: 'meters',
      tracking: {
        planeDetection: true,
        stabilizationFrames: 30,
        minFeaturePoints: 30,
        hitTestRefreshRate: 10,
        environmentEstimation: true,
        planeOpacity: 0.5, // Adjust plane opacity
        planeColor: 0xffffff // White planes
      },
      reticle: {
        ringRadius: 0.15,
        ringThickness: 0.05,
        segments: 32,
        color: 0xffffff,
        opacity: 0.8,
        pulseSpeed: 0.5,
        pulseMin: 0.9,
        pulseMax: 1.1,
        circleRadius: 0.1,
        circleSegments: 24,
        gridSize: 0.3,
        gridDivisions: 8,
        gridColor: 0xffffff,
        gridOpacity: 0.3,
        stableColor: 0x00ff00,
        unstableColor: 0xff4444
      }
    };

    // Global variables
    let scene, camera, renderer;
    let model = null;
    let reticle = null;
    let reticlePulse = 1;
    let reticlePulseDirection = 1;
    let arjsScene = null;
    let isModelPlaced = false;
    let currentScale = config.initialScale;
    let lastPosition = new THREE.Vector3();
    let hammerManager = null;
    let initialDistance = 0;
    let initialScale = 1;
    let initialAngle = 0;
    let initialRotation = 0;
    let modelBoundingBox = new THREE.Box3();
    let modelAnchor = null;
    let modelGroup = null;
    let frameCounter = 0;
    let stabilityScore = 0;
    let hitTestCounter = 0;
    let lastStablePosition = null;
    let featurePoints = [];
    let planeMeshes = []; // Only declared once here
    let isSessionStarted = false;
    let xrSession = null;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let referenceSpace = null;
    let lastHitTestPose = null;
    let lastStabilityUpdateTime = 0;
    let detectedPlanes = new Set();
    let featurePointCloud = null;

    // Enhanced WebXR support check
    async function checkXRSupport() {
      // First check if WebXR is supported at all
      if (!('xr' in navigator)) {
        return false;
      }

      // Check for immersive-ar support
      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (supported) return true;
      } catch (e) {
        console.error("WebXR support check error:", e);
      }

      // Android-specific checks
      const isAndroid = /android/i.test(navigator.userAgent);
      if (isAndroid) {
        try {
          // Check if ARCore is supported and installed
          const arCoreSupported = await checkARCoreSupport();
          return arCoreSupported;
        } catch (e) {
          console.error("ARCore check failed:", e);
        }
      }

      return false;
    }

    async function checkARCoreSupport() {
      return new Promise((resolve) => {
        if (window.ARCore) {
          ARCore.getARAvailability().then((availability) => {
            resolve(availability === 'SUPPORTED_INSTALLED');
          }).catch(() => resolve(false));
        } else {
          // Fallback check for Chrome's WebXR AR support
          const isChrome = /chrome|chromium|crios/i.test(navigator.userAgent);
          const chromeVersionMatch = navigator.userAgent.match(/Chrome\/(\d+)/);
          const chromeVersion = chromeVersionMatch ? parseInt(chromeVersionMatch[1]) : 0;
          
          // Chrome 81+ supports WebXR on Android with ARCore
          resolve(isChrome && chromeVersion >= 81);
        }
      });
    }

    // Check camera permissions with enhanced error handling
    async function checkCameraPermissions() {
      try {
        // First check if permissions API is available
        if (navigator.permissions && navigator.permissions.query) {
          try {
            const permissionStatus = await navigator.permissions.query({ name: 'camera' });
            if (permissionStatus.state === 'denied') {
              return false;
            }
          } catch (e) {
            console.log("Permissions API not fully supported, proceeding...");
          }
        }

        // Android-specific device orientation permission
        const isAndroid = /android/i.test(navigator.userAgent);
        if (isAndroid && typeof DeviceOrientationEvent !== 'undefined' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission !== 'granted') {
              console.log("Device orientation permission denied");
              return false;
            }
          } catch (e) {
            console.error("Device orientation permission error:", e);
            return false;
          }
        }

        // Test camera access with getUserMedia
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: { ideal: 'environment' },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        
        // Immediately stop tracks to release camera
        stream.getTracks().forEach(track => track.stop());
        return true;
      } catch (e) {
        console.error("Camera permission error:", e);
        return false;
      }
    }

    // Create advanced reticle with stability feedback
    function createReticle() {
      const reticleGroup = new THREE.Group();
      
      // Outer ring with stability indicator
      const ringGeometry = new THREE.RingGeometry(
        config.reticle.ringRadius, 
        config.reticle.ringRadius + config.reticle.ringThickness, 
        config.reticle.segments
      ).rotateX(-Math.PI / 2);
      
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: config.reticle.color,
        transparent: true,
        opacity: config.reticle.opacity,
        side: THREE.DoubleSide
      });
      
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      reticleGroup.add(ring);
      
      // Inner circle with subtle grid pattern
      const circleGeometry = new THREE.CircleGeometry(
        config.reticle.circleRadius, 
        config.reticle.circleSegments
      ).rotateX(-Math.PI / 2);
      
      const circleMaterial = new THREE.MeshBasicMaterial({
        color: config.reticle.color,
        transparent: true,
        opacity: config.reticle.opacity,
        side: THREE.DoubleSide
      });
      
      const circle = new THREE.Mesh(circleGeometry, circleMaterial);
      reticleGroup.add(circle);
      
      // Detailed grid mesh with adaptive resolution
      const gridGeometry = new THREE.PlaneGeometry(
        config.reticle.gridSize, 
        config.reticle.gridSize, 
        config.reticle.gridDivisions, 
        config.reticle.gridDivisions
      ).rotateX(-Math.PI / 2);
      
      const gridMaterial = new THREE.MeshBasicMaterial({
        color: config.reticle.gridColor,
        transparent: true,
        opacity: config.reticle.gridOpacity,
        wireframe: true
      });
      
      const grid = new THREE.Mesh(gridGeometry, gridMaterial);
      reticleGroup.add(grid);
      
      // Add small dots at grid intersections for better spatial perception
      const dotGeometry = new THREE.BufferGeometry();
      const positions = [];
      const size = config.reticle.gridSize;
      const divisions = config.reticle.gridDivisions;
      const step = size / divisions;
      
      for (let i = 0; i <= divisions; i++) {
        for (let j = 0; j <= divisions; j++) {
          positions.push(
            -size/2 + i * step,
            0,
            -size/2 + j * step
          );
        }
      }
      
      dotGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const dotMaterial = new THREE.PointsMaterial({
        color: config.reticle.gridColor,
        size: 0.005,
        transparent: true,
        opacity: config.reticle.gridOpacity * 1.5
      });
      
      const dots = new THREE.Points(dotGeometry, dotMaterial);
      reticleGroup.add(dots);
      
      reticleGroup.matrixAutoUpdate = false;
      reticleGroup.visible = false;
      reticleGroup.userData.materials = {
        ring: ringMaterial,
        circle: circleMaterial,
        grid: gridMaterial,
        dots: dotMaterial
      };
      
      return reticleGroup;
    }

    // Update reticle appearance based on stability
    function updateReticleStability(stability) {
      if (!reticle || !reticle.userData.materials) return;
      
      const color = new THREE.Color().lerpColors(
        new THREE.Color(config.reticle.unstableColor),
        new THREE.Color(config.reticle.stableColor),
        stability
      );
      
      Object.values(reticle.userData.materials).forEach(material => {
        if (material) {
          material.color.copy(color);
        }
      });
      
      // Update stability meter UI
      const stabilityProgress = document.getElementById('stability-progress');
      if (stabilityProgress) {
        stabilityProgress.style.width = `${stability * 100}%`;
      }
    }

    // Initialize WebXR with enhanced tracking features
    async function initWebXR() {
      try {
        const hasPermission = await checkCameraPermissions();
        if (!hasPermission) {
          showCameraError();
          return;
        }

        // Create Three.js scene with environment estimation
        scene = new THREE.Scene();
        scene.background = null;
        
        camera = new THREE.PerspectiveCamera(
          60, 
          window.innerWidth / window.innerHeight, 
          0.01, // Near plane very small for AR
          100
        );
        
        renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true,
          powerPreference: "high-performance",
          logarithmicDepthBuffer: true
        });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        renderer.xr.enabled = true;
        renderer.physicallyCorrectLights = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.getElementById('ar-container').appendChild(renderer.domElement);
        
        // Enhanced lighting for environment estimation
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0.5, 1, 0.25);
        directionalLight.castShadow = true;
        directionalLight.shadow.bias = -0.001;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Create advanced reticle
        reticle = createReticle();
        scene.add(reticle);
        
        // Modify your createReticle function to add this:
        reticle.userData = {
          lastPositions: [],
          addPosition: function(position) {
            this.lastPositions.push({ position, time: performance.now() });
            // Keep only recent positions
            if (this.lastPositions.length > 10) {
              this.lastPositions.shift();
            }
          },
          getStability: function() {
            if (this.lastPositions.length < 2) return 0;
            
            let totalMovement = 0;
            for (let i = 1; i < this.lastPositions.length; i++) {
              totalMovement += this.lastPositions[i].position.distanceTo(
                this.lastPositions[i-1].position
              );
            }
            
            const avgMovement = totalMovement / (this.lastPositions.length - 1);
            const timeSpan = this.lastPositions[this.lastPositions.length-1].time - 
                            this.lastPositions[0].time;
            
            // Normalize movement to meters per second
            const movementPerSecond = avgMovement / (timeSpan / 1000);
            
            // Convert to stability score (0-1)
            return Math.max(0, 1 - (movementPerSecond / 0.01)); // Using fixed threshold for movement
          }
        };
        
        // Create a group to hold the model for stable positioning
        modelGroup = new THREE.Group();
        scene.add(modelGroup);
        
        // Load model with proper scaling and error handling
        const loader = new THREE.GLTFLoader();
        try {
          const gltf = await loader.loadAsync(config.modelUrl);
          model = gltf.scene;
          
          // Calculate bounding box to determine proper scale
          modelBoundingBox.setFromObject(model);
          const size = modelBoundingBox.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          
          // Adjust scale based on model size
          const targetSize = 1.0; // Target size in meters
          const scaleFactor = targetSize / maxDim;
          
          model.scale.set(scaleFactor, scaleFactor, scaleFactor);
          currentScale = scaleFactor;
          
          model.visible = false;
          modelGroup.add(model);
          
          if (config.debug) {
            console.log(`Model loaded with initial scale: ${scaleFactor.toFixed(2)}`);
            // Add bounding box helper for debugging
            const bboxHelper = new THREE.Box3Helper(modelBoundingBox, 0xffff00);
            bboxHelper.visible = false;
            model.add(bboxHelper);
          }
        } catch (e) {
          console.error("Failed to load model:", e);
          // Fallback cube with proper scaling
          model = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ 
              color: 0x00ff00,
              roughness: 0.7,
              metalness: 0.3
            })
          );
          model.castShadow = true;
          model.visible = false;
          modelGroup.add(model);
        }
        
        // Start AR session with enhanced features
        const sessionInit = { 
          requiredFeatures: ['hit-test', 'dom-overlay'],
          optionalFeatures: ['plane-detection', 'anchors', 'light-estimation', 'depth-sensing']
        };
        
        xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
        await renderer.xr.setSession(xrSession);
        
        // Set up reference space
        referenceSpace = await xrSession.requestReferenceSpace('local');
        
        // Enable plane detection if supported
        if (xrSession.enabledFeatures && xrSession.enabledFeatures.includes('plane-detection')) {
          referenceSpace = await xrSession.requestReferenceSpace('local-floor');
          const planeDetectionState = { enabled: true };
          xrSession.updateWorldTrackingState({ planeDetectionState });
        }
        
        // Enable light estimation if supported
        if (xrSession.enabledFeatures && xrSession.enabledFeatures.includes('light-estimation')) {
          const lightEstimationState = { enabled: true };
          xrSession.updateWorldTrackingState({ lightEstimationState });
        }
        
        isSessionStarted = true;
        document.getElementById('loading').style.display = 'none';
        document.getElementById('gesture-help').style.display = 'block';
        document.getElementById('surface-indicator').style.display = 'block';
        document.getElementById('stability-meter').style.display = 'block';
        if (config.debug) document.getElementById('debug-info').style.display = 'block';
        
        // Set up controller for placement
        const controller = renderer.xr.getController(0);
        controller.addEventListener('select', placeModel);
        scene.add(controller);
        
        // Set up hit test source for surface detection
        setupHitTestSource();
        
        // Set up gesture controls after model is placed
        setupGestureControls();
        
        // Start animation loop
        renderer.setAnimationLoop(render);
      } catch (e) {
        console.error("WebXR initialization failed:", e);
        fallbackToARJS();
      }
    }

    // New function to handle plane detection updates
    function updatePlaneDetection(event) {
      if (!event.detectedPlanes) return;

      for (const plane of event.detectedPlanes) {
        if (!detectedPlanes.has(plane.uuid)) {
          createPlaneMesh(plane);
          detectedPlanes.add(plane.uuid);
        } else {
          updatePlaneMesh(plane);
        }
      }
      
      // Update feature points if available
      if (event.detectedFeaturePoints && config.debug) {
        updateFeaturePoints(event.detectedFeaturePoints);
      }
    }

    // Create a mesh for a detected plane
    function createPlaneMesh(plane) {
      const planeGeometry = new THREE.PlaneGeometry(1, 1);
      const planeMaterial = new THREE.MeshBasicMaterial({
        color: config.tracking.planeColor,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: config.tracking.planeOpacity,
        wireframe: false
      });
      
      const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
      planeMesh.matrixAutoUpdate = false;
      planeMesh.userData.plane = plane;
      
      // Align with the plane's orientation
      planeMesh.rotation.x = -Math.PI / 2;
      
      scene.add(planeMesh);
      planeMeshes.push(planeMesh);
      
      if (config.debug) {
        console.log(`New plane detected: ${plane.uuid}`);
      }
    }

    // Update an existing plane mesh
    function updatePlaneMesh(plane) {
      const planeMesh = planeMeshes.find(mesh => mesh.userData.plane.uuid === plane.uuid);
      if (!planeMesh) return;
      
      // Update geometry based on plane's extent
      const width = plane.extent?.width || 1;
      const height = plane.extent?.height || 1;
      
      planeMesh.geometry.dispose();
      planeMesh.geometry = new THREE.PlaneGeometry(width, height);
      
      // Update position and orientation
      planeMesh.matrix.fromArray(plane.pose.transform.matrix);
      planeMesh.matrix.decompose(planeMesh.position, planeMesh.quaternion, planeMesh.scale);
      
      if (config.debug) {
        planeMesh.material.wireframe = true;
      }
    }

    // Update feature point visualization
    function updateFeaturePoints(points) {
      const positions = new Float32Array(points.length * 3);
      
      for (let i = 0; i < points.length; i++) {
        positions[i * 3] = points[i].x;
        positions[i * 3 + 1] = points[i].y;
        positions[i * 3 + 2] = points[i].z;
      }
      
      featurePointCloud.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      featurePointCloud.geometry.attributes.position.needsUpdate = true;
    }

    // Replace the existing setupHitTestSource function with this improved version
    async function setupHitTestSource() {
      if (!xrSession || !referenceSpace || hitTestSourceRequested) return;
      
      try {
        // First try with the most accurate configuration
        hitTestSource = await xrSession.requestHitTestSource({
          space: referenceSpace,
          entityTypes: ['plane', 'mesh'],
          offsetRay: new XRRay(new DOMPoint(0, 0, 0), { 
            direction: {x: 0, y: -1, z: 0, w: 1} // Pointing downward
          })
        });
        
        hitTestSourceRequested = true;
        
        // Add session end handler to clean up
        xrSession.addEventListener('end', () => {
          hitTestSourceRequested = false;
          if (hitTestSource) {
            hitTestSource.cancel();
            hitTestSource = null;
          }
        });
        
        if (config.debug) {
          console.log("Hit test source created successfully");
        }
      } catch (e) {
        console.error("Failed to create hit test source:", e);
        
        // Fallback to simpler configuration
        try {
          hitTestSource = await xrSession.requestHitTestSource({
            space: referenceSpace,
            entityTypes: ['plane']
          });
          
          hitTestSourceRequested = true;
          
          if (config.debug) {
            console.log("Fallback hit test source created successfully");
          }
        } catch (e) {
          console.error("Failed to create fallback hit test source:", e);
          // Last resort - try without specifying entity types
          try {
            hitTestSource = await xrSession.requestHitTestSource({
              space: referenceSpace
            });
            hitTestSourceRequested = true;
          } catch (e) {
            console.error("Completely failed to create hit test source:", e);
          }
        }
      }
    }

    // Replace the render function with this improved version
    function render(timestamp, frame) {
      if (!frame) return;
      
      // Get the XRViewerPose for the current frame
      const pose = frame.getViewerPose(referenceSpace);
      if (!pose) return;
      
      // Update camera position
      camera.matrix.fromArray(pose.transform.matrix);
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      
      // Process hit test results if we have a hit test source
      if (hitTestSource && !isModelPlaced) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const hitPose = hit.getPose(referenceSpace);
          
          if (hitPose) {
            reticle.visible = true;
            reticle.matrix.fromArray(hitPose.transform.matrix);
            
            // Calculate stability metrics
            const currentPosition = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
            const currentTime = performance.now();
            
            if (lastStablePosition) {
              // Calculate movement since last frame
              const distanceMoved = lastStablePosition.distanceTo(currentPosition);
              const timeElapsed = currentTime - lastStabilityUpdateTime;
              
              // Normalize movement based on time
              const normalizedMovement = distanceMoved / Math.max(1, timeElapsed);
              
              // Update stability score (lower movement = higher stability)
              stabilityScore = Math.max(0, Math.min(1, 
                stabilityScore * 0.8 + (1 - Math.min(1, normalizedMovement * 10)) * 0.2
              ));
              
              // Update reticle appearance
              updateReticleStability(stabilityScore);
              
              // Update surface indicator
              updateSurfaceIndicator(currentPosition);
            }
            
            lastStablePosition = currentPosition.clone();
            lastStabilityUpdateTime = currentTime;
          }
        } else {
          reticle.visible = false;
          stabilityScore = 0;
          updateReticleStability(0);
          document.getElementById('surface-indicator').style.display = 'none';
        }
      }
      
      // Render the scene
      renderer.render(scene, camera);
    }

    // Improved surface indicator update
    function updateSurfaceIndicator(position) {
      const indicator = document.getElementById('surface-indicator');
      if (!indicator) return;
      
      // Convert 3D position to 2D screen coordinates
      const vector = position.clone().project(camera);
      
      const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
      const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
      
      // Only show if position is in front of camera
      if (vector.z > 0 && vector.z <= 1) {
        indicator.style.left = `${x - 20}px`;
        indicator.style.top = `${y - 20}px`;
        indicator.style.display = 'block';
        
        // Add pulse animation based on stability
        const pulseScale = 0.8 + (0.4 * stabilityScore);
        indicator.style.transform = `scale(${pulseScale})`;
        indicator.style.opacity = stabilityScore;
      } else {
        indicator.style.display = 'none';
      }
    }

    // Initialize AR.js fallback mode with enhanced features
    async function initARJS() {
      try {
        const hasPermission = await checkCameraPermissions();
        if (!hasPermission) {
          showCameraError();
          return;
        }

        document.getElementById('ar-container').innerHTML = `
          <a-scene 
            vr-mode-ui="enabled: false"
            arjs="sourceType: webcam; 
                  detectionMode: mono_and_matrix; 
                  matrixCodeType: 3x3;
                  debugUIEnabled: ${config.debug};
                  maxDetectionRate: 60;
                  cameraParametersUrl: https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/data/camera_para.dat"
            renderer="logarithmicDepthBuffer: true; precision: high; alpha: true"
            embedded
            cursor="rayOrigin: mouse; fuse: false"
            raycaster="objects: .clickable">
            
            <a-camera gps-camera rotation-reader></a-camera>
            
            <!-- Enhanced plane detection with white mesh -->
            <a-entity id="ar-planes" 
                     geometry="primitive: plane; width: 100; height: 100" 
                     material="color: white; opacity: ${config.tracking.planeOpacity}; shader: flat; side: double"
                     rotation="-90 0 0" 
                     class="clickable">
            </a-entity>
            
            <!-- Rest of your AR.js scene setup -->
          </a-scene>
        `;
        
        // Rest of your AR.js initialization
      } catch (e) {
        console.error("AR.js initialization failed:", e);
        document.getElementById('support-message').innerHTML = 
          '<p class="unsupported">Failed to initialize AR. Your device may not support AR features.</p>';
      }
    }

    function setupAndroidSpecificUI() {
      const isAndroid = /android/i.test(navigator.userAgent);
      if (isAndroid) {
        // Adjust UI elements for Android
        document.getElementById('info').style.fontSize = '16px';
        document.getElementById('gesture-help').style.bottom = '80px';
        
        // Add Android-specific instructions
        const androidHelp = document.createElement('div');
        androidHelp.id = 'android-help';
        androidHelp.style.position = 'fixed';
        androidHelp.style.bottom = '120px';
        androidHelp.style.left = '0';
        androidHelp.style.right = '0';
        androidHelp.style.textAlign = 'center';
        androidHelp.style.color = 'white';
        androidHelp.style.backgroundColor = 'rgba(0,0,0,0.7)';
        androidHelp.style.padding = '10px';
        androidHelp.style.borderRadius = '5px';
        androidHelp.innerHTML = 'On Android: Move device slowly to detect surfaces';
        document.body.appendChild(androidHelp);
      }
    }

    function logError(error) {
      console.error(error);
      if (config.debug) {
        const errorDisplay = document.getElementById('error-display') || 
          document.createElement('div');
        errorDisplay.id = 'error-display';
        errorDisplay.style.position = 'fixed';
        errorDisplay.style.top = '0';
        errorDisplay.style.left = '0';
        errorDisplay.style.color = 'red';
        errorDisplay.style.backgroundColor = 'rgba(0,0,0,0.7)';
        errorDisplay.style.padding = '10px';
        errorDisplay.style.zIndex = '1000';
        errorDisplay.textContent = `Error: ${error.message || error}`;
        document.body.appendChild(errorDisplay);
      }
    }

    async function startARExperience() {
      try {
        // First try WebXR
        await initWebXR();
      } catch (e) {
        console.log("WebXR failed, trying AR.js");
        try {
          await initARJS();
        } catch (e2) {
          console.log("AR.js failed, showing fallback");
          showUnsupportedMessage();
        }
      }
    }

    // Place model in WebXR mode with enhanced anchoring
    async function placeModel() {
      if (!isModelPlaced && reticle.visible && stabilityScore > 0.7) {
        try {
          // Create an anchor at the reticle position
          const anchorPose = new XRRigidTransform(
            new DOMPointReadOnly(reticle.position.x, reticle.position.y, reticle.position.z),
            { x: 0, y: 0, z: 0, w: 1 }
          );
          
          modelAnchor = await xrSession.createAnchor(anchorPose, referenceSpace);
          
          // Position the model group at the anchor's position
          modelGroup.position.set(0, 0, 0);
          model.visible = true;
          isModelPlaced = true;
          
          // Add the model group to the anchor's space
          const anchorGroup = new THREE.Group();
          anchorGroup.matrix.fromArray(modelAnchor.anchorSpace.getTransformTo(referenceSpace).matrix);
          anchorGroup.add(modelGroup);
          scene.add(anchorGroup);
          
          // Change reticle color to indicate placement
          updateReticleStability(1.0);
          
          // Hide surface indicator
          document.getElementById('surface-indicator').style.display = 'none';
          
          if (config.debug) {
            console.log("Model anchored to real world position");
            // Visualize the anchor point
            const anchorHelper = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 16, 16),
              new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            anchorHelper.position.setFromMatrixPosition(anchorGroup.matrix);
            scene.add(anchorHelper);
          }
        } catch (e) {
          console.error("Failed to create anchor:", e);
          // Fallback to non-anchored placement
          modelGroup.position.setFromMatrixPosition(reticle.matrix);
          modelGroup.quaternion.setFromRotationMatrix(reticle.matrix);
          model.visible = true
          isModelPlaced = true;
        }
      }
    }

    // Place model in AR.js mode
    function placeModelARJS(position) {
      const modelEl = document.getElementById('model');
      modelEl.setAttribute('visible', 'true');
      modelEl.setAttribute('position', position);
      isModelPlaced = true;
      
      // Hide surface indicator
      document.getElementById('surface-indicator').style.display = 'none';
    }

    // Set up advanced gesture controls for WebXR
    function setupGestureControls() {
      const canvas = renderer.domElement;
      hammerManager = new Hammer.Manager(canvas, {
        recognizers: [
          [Hammer.Pan, { direction: Hammer.DIRECTION_ALL, threshold: 5 }],
          [Hammer.Pinch, { threshold: 0.1 }],
          [Hammer.Rotate, { threshold: 0.1 }]
        ]
      });
      
      // Single finger pan to move model
      hammerManager.on("panstart", (e) => {
        if (isModelPlaced) {
          lastPosition.copy(modelGroup.position);
        }
      });
      
      hammerManager.on("pan", (e) => {
        if (isModelPlaced && e.pointers.length === 1) {
          // Convert screen coordinates to world position using raycasting
          const vector = new THREE.Vector2(
            (e.center.x / window.innerWidth) * 2 - 1,
            -(e.center.y / window.innerHeight) * 2 + 1
          );
          
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(vector, camera);
          
          // Create a plane at the model's position for intersection
          const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(plane, intersection);
          
          if (intersection) {
            // Update model position relative to its anchor
            if (modelAnchor) {
              const anchorMatrix = new THREE.Matrix4().fromArray(
                modelAnchor.anchorSpace.getTransformTo(referenceSpace).matrix
              );
              const worldPosition = intersection.clone().sub(new THREE.Vector3().setFromMatrixPosition(anchorMatrix));
              modelGroup.position.copy(worldPosition);
            } else {
              modelGroup.position.copy(intersection);
            }
          }
        }
      });
      
      // Two finger pinch to scale model
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          initialScale = currentScale;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          currentScale = Math.min(config.maxScale, 
                                Math.max(config.minScale, initialScale * e.scale));
          model.scale.set(currentScale, currentScale, currentScale);
        }
      });
      
      // Two finger rotate to rotate model
      hammerManager.on("rotatestart", (e) => {
        if (isModelPlaced) {
          initialRotation = modelGroup.rotation.y;
        }
      });
      
      hammerManager.on("rotate", (e) => {
        if (isModelPlaced) {
          modelGroup.rotation.y = initialRotation + e.rotation * (Math.PI / 180);
        }
      });
      
      // Add inertia for smoother interaction
      hammerManager.on("panend", (e) => {
        // Could add inertia here if desired
      });
    }

    // Set up gesture controls for AR.js
 function setupARJSGestureControls(modelEl) {
      const container = document.getElementById('ar-container');
      hammerManager = new Hammer.Manager(container, {
        recognizers: [
          [Hammer.Pan, { direction: Hammer.DIRECTION_ALL, threshold: 5 }],
          [Hammer.Pinch, { threshold: 0.1 }],
          [Hammer.Rotate, { threshold: 0.1 }]
        ]
      });
      
      let startPosition = null;
      let startScale = config.initialScale;
      let startRotation = 0;
      
      // [Other event handlers remain the same]
      
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          startScale = modelEl.getAttribute('scale').x;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          const newScale = Math.min(config.maxScale, 
                                  Math.max(config.minScale, startScale * e.scale));
          modelEl.setAttribute('scale', {
            x: newScale,
            y: newScale,
            z: newScale
          });
        }
      });
      hammerManager.on("pinchstart", (e) => {
        if (isModelPlaced) {
          startScale = modelEl.getAttribute('scale').x;
        }
      });
      
      hammerManager.on("pinch", (e) => {
        if (isModelPlaced) {
          const newScale = Math.min(config.maxScale, 
                                  Math.max(config.minScale, startScale * e.scale));
          modelEl.setAttribute('scale', {
            x: newScale,
            y: newScale,
            z: newScale
          });
        }
      });
      
      hammerManager.on("rotatestart", (e) => {
        if (isModelPlaced) {
          startRotation = modelEl.getAttribute('rotation').y || 0;
        }
      });
      
      hammerManager.on("rotate", (e) => {
        if (isModelPlaced) {
          const newRotation = startRotation + e.rotation;
          modelEl.setAttribute('rotation', {
            x: 0,
            y: newRotation,
            z: 0
          });
        }
      });
    }

    // Enhanced WebXR render loop with stability tracking
    function render(timestamp, frame) {
      if (!frame) return;
      
      // Store the frame for use in other functions
      window.frame = frame;
      
      // Update reticle pulse animation
      if (reticle && !isModelPlaced) {
        reticlePulse += config.reticle.pulseSpeed * 0.01 * reticlePulseDirection;
        if (reticlePulse > config.reticle.pulseMax || reticlePulse < config.reticle.pulseMin) {
          reticlePulseDirection *= -1;
        }
        
        reticle.scale.set(reticlePulse, reticlePulse, reticlePulse);
        
        // Get hit test results for surface detection
        const hitTestResults = frame.getHitTestResults(window.hitTestSource);
        
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);
          
          if (pose) {
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
            
            // Calculate stability based on how much the reticle has moved
            const currentPosition = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
            
            if (lastStablePosition) {
              const distanceMoved = lastStablePosition.distanceTo(currentPosition);
              const timeDiff = timestamp - lastStabilityUpdateTime;
              
              // Stability increases when movement is small and time difference is small
              const movementFactor = Math.max(0, 1 - distanceMoved * 10);
              const timeFactor = Math.min(1, timeDiff / 100);
              stabilityScore = Math.min(1, stabilityScore * 0.9 + movementFactor * timeFactor * 0.1);
              
              // Update reticle appearance based on stability
              updateReticleStability(stabilityScore);
            }
            
            lastStablePosition = currentPosition.clone();
            lastStabilityUpdateTime = timestamp;
            
            // Update surface indicator position
            updateSurfaceIndicator(currentPosition);
            
            if (config.debug) {
              // Show debug info
              const debugInfo = document.getElementById('debug-info');
              if (debugInfo) {
                debugInfo.innerHTML = `
                  Position: ${currentPosition.x.toFixed(2)}, ${currentPosition.y.toFixed(2)}, ${currentPosition.z.toFixed(2)}<br>
                  Stability: ${(stabilityScore * 100).toFixed(0)}%<br>
                  FPS: ${Math.round(renderer.info.render.frame / (performance.now() / 1000))}
                `;
              }
            }
          }
        } else {
          reticle.visible = false;
          stabilityScore = 0;
          updateReticleStability(0);
          document.getElementById('surface-indicator').style.display = 'none';
        }
      }
      
      // Request hit test source if not already done
      hitTestCounter++;
      if (hitTestCounter % config.tracking.hitTestRefreshRate === 0 && !hitTestSourceRequested) {
        setupHitTestSource();
      }
      
      renderer.render(scene, camera);
    }

    // Update surface indicator position for WebXR
    function updateSurfaceIndicator(position) {
      const indicator = document.getElementById('surface-indicator');
      if (!indicator) return;
      
      position.project(camera);
      
      const x = (position.x * 0.5 + 0.5) * window.innerWidth;
      const y = -(position.y * 0.5 - 0.5) * window.innerHeight;
      
      indicator.style.left = `${x - 20}px`;
      indicator.style.top = `${y - 20}px`;
      indicator.style.display = 'block';
      
      // Add pulse animation based on stability
      const pulseScale = 1 + (0.2 * (1 - stabilityScore));
      indicator.style.transform = `scale(${pulseScale})`;
    }

    // Show camera error message
   function showCameraError() {
  const supportMessage = document.getElementById('support-message');
  supportMessage.innerHTML = `
    <div class="unsupported">
      <p>Camera access is required for AR features.</p>
      <p>Please enable camera permissions in your browser settings.</p>
      ${/android/i.test(navigator.userAgent) ? 
        '<p>On Android: Tap the camera icon in the address bar and select "Allow".</p>' : ''}
      <button id="retry-button" style="margin-top: 15px;">Retry</button>
    </div>
  `;
  
  document.getElementById('retry-button').addEventListener('click', async () => {
    const supported = await checkXRSupport();
    if (supported) {
      initWebXR();
    } else {
      fallbackToARJS();
    }
  });
}

    // Fallback to AR.js
    function fallbackToARJS() {
      console.log("Falling back to AR.js");
      document.getElementById('support-message').innerHTML = 
        '<p>Using fallback AR mode. For best experience, use a WebXR compatible device.</p>';
      initARJS();
    }

    // Handle window resize
    function onWindowResize() {
      if (camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight, false);
      }
    }

    // Start button event listener
  document.getElementById('start-button').addEventListener('click', async () => {
  const startButton = document.getElementById('start-button');
  startButton.disabled = true;
  startButton.textContent = 'Initializing...';
  
  try {
    const hasPermission = await checkCameraPermissions();
    if (!hasPermission) {
      showCameraError();
      startButton.disabled = false;
      startButton.textContent = 'Start AR Experience';
      return;
    }
    
    const supported = await checkXRSupport();
    if (supported) {
      await initWebXR();
    } else {
      await initARJS();
    }
  } catch (e) {
    console.error("Failed to start AR experience:", e);
    document.getElementById('support-message').innerHTML = `
      <p class="unsupported">Failed to initialize AR: ${e.message}</p>
    `;
    startButton.disabled = false;
    startButton.textContent = 'Try Again';
  }
});

   // Initialize on load
window.addEventListener('DOMContentLoaded', () => {
  window.addEventListener('resize', onWindowResize);
  
  // Check for WebXR support immediately to show appropriate UI
  checkXRSupport().then(supported => {
    if (!supported) {
      document.getElementById('support-message').innerHTML = 
        '<p>For the best experience, use a device with WebXR support (iOS 15+ or Android with Chrome 81+).</p>';
    }
  });

  // Move the start button event listener inside DOMContentLoaded
  const startButton = document.getElementById('start-button');
  if (startButton) {
    startButton.addEventListener('click', async () => {
      const supported = await checkXRSupport();
      startButton.disabled = true;
      
      if (supported) {
        initWebXR();
      } else {
        fallbackToARJS();
      }
    });
  } else {
    console.error("Start button not found in the DOM");
  }
});
  </script>
</body>
</html>
