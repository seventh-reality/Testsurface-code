<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>SLAM-based Web AR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="info">Move your device to detect surfaces. Tap to place object.</div>
    <div id="loading">Initializing AR, please wait...</div>
    
    <!-- Load Three.js first -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- Load AR.js with a fallback -->
    <script>
        // Function to load AR.js with error handling
        function loadARJS() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@ar-js-org/ar.js@3.2.0/dist/ar.js';
                script.onload = () => {
                    if (typeof THREEx !== 'undefined') {
                        resolve();
                    } else {
                        reject(new Error('AR.js loaded but THREEx not defined'));
                    }
                };
                script.onerror = () => reject(new Error('Failed to load AR.js'));
                document.head.appendChild(script);
            });
        }

        // Main initialization
        loadARJS()
            .then(() => {
                // AR.js loaded successfully, initialize the app
                init();
            })
            .catch(error => {
                console.error('AR.js loading error:', error);
                document.getElementById('loading').textContent = 
                    "Error: Could not load AR components. Please check your internet connection and refresh the page.";
            });
    </script>
    
    <script>
        // Global variables
        let scene, camera, renderer;
        let arToolkitSource, arToolkitContext;
        let reticle, placedObjects = [];
        let hitTestPlane, raycaster;
        let isInitialized = false;

        function init() {
            // Initialize Three.js
            initThreeJS();
            
            // Initialize AR.js
            initARJS();
            
            // Set up event listeners
            setupEventListeners();
            
            // Start animation loop
            animate();
        }

        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                precision: 'highp'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create reticle for surface placement
            createReticle();
            
            // Create hit test plane (invisible plane for raycasting)
            hitTestPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            hitTestPlane.rotation.x = -Math.PI / 2;
            scene.add(hitTestPlane);
            
            // Create raycaster for hit testing
            raycaster = new THREE.Raycaster();
        }

        function createReticle() {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.15, 32);
            const dotGeometry = new THREE.CircleGeometry(0.03, 32);
            
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const dotMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            
            const reticleGroup = new THREE.Group();
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            const dot = new THREE.Mesh(dotGeometry, dotMaterial);
            
            ring.rotation.x = -Math.PI / 2;
            dot.rotation.x = -Math.PI / 2;
            dot.position.y = 0.001;
            
            reticleGroup.add(ring);
            reticleGroup.add(dot);
            reticleGroup.visible = false;
            
            scene.add(reticleGroup);
            reticle = reticleGroup;
        }

        function initARJS() {
            try {
                // Create AR source (webcam)
                arToolkitSource = new THREEx.ArToolkitSource({
                    sourceType: 'webcam',
                    sourceWidth: window.innerWidth,
                    sourceHeight: window.innerHeight,
                    displayWidth: window.innerWidth,
                    displayHeight: window.innerHeight
                });
                
                // Initialize AR context
                arToolkitContext = new THREEx.ArToolkitContext({
                    cameraParametersUrl: 'https://ar-js-org.github.io/AR.js/data/data/camera_para.dat',
                    detectionMode: 'mono',
                    maxDetectionRate: 60,
                    canvasWidth: window.innerWidth,
                    canvasHeight: window.innerHeight,
                    debug: false
                });
                
                // Handle source initialization
                arToolkitSource.init(() => {
                    arToolkitSource.onResizeElement();
                    arToolkitSource.copyElementSizeTo(renderer.domElement);
                    
                    // Start camera stream
                    startCamera();
                    
                    // Initialize AR context
                    arToolkitContext.init(() => {
                        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                        isInitialized = true;
                        document.getElementById('loading').style.display = 'none';
                    });
                });
            } catch (error) {
                console.error('AR.js initialization error:', error);
                document.getElementById('loading').textContent = 
                    "Error: AR initialization failed. Please refresh the page.";
            }
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } 
            })
            .then(stream => {
                const video = document.createElement('video');
                video.setAttribute('autoplay', '');
                video.setAttribute('playsinline', '');
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    // Assign to AR.js source
                    arToolkitSource.domElement = video;
                };
            })
            .catch(err => {
                console.error("Camera error:", err);
                document.getElementById('loading').textContent = 
                    "Could not access camera. Please ensure you've granted camera permissions.";
            });
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onTap);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (arToolkitSource) {
                arToolkitSource.onResizeElement();
                arToolkitSource.copyElementSizeTo(renderer.domElement);
            }
        }

        function onTap(event) {
            if (!reticle.visible || !isInitialized) return;
            
            createObjectAtPosition(reticle.position, reticle.quaternion);
        }

        function createObjectAtPosition(position, quaternion) {
            const geometry = new THREE.ConeGeometry(0.05, 0.1, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                roughness: 0.2,
                metalness: 0.3
            });
            
            const object = new THREE.Mesh(geometry, material);
            object.position.copy(position);
            object.quaternion.copy(quaternion);
            
            object.userData = {
                scale: 1,
                pulseDirection: 1,
                rotationSpeed: Math.random() * 0.02 - 0.01
            };
            
            scene.add(object);
            placedObjects.push(object);
            
            if (placedObjects.length > 10) {
                const oldObject = placedObjects.shift();
                scene.remove(oldObject);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isInitialized) return;
            
            updateARTracking();
            updatePlacedObjects();
            renderer.render(scene, camera);
        }

        function updateARTracking() {
            if (arToolkitContext.ready) {
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                
                if (Math.random() > 0.97) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObject(hitTestPlane);
                    
                    if (intersects.length > 0) {
                        const point = intersects[0].point;
                        reticle.position.copy(point);
                        reticle.quaternion.copy(camera.quaternion);
                        reticle.visible = true;
                    }
                }
            }
        }

        function updatePlacedObjects() {
            placedObjects.forEach(obj => {
                obj.userData.scale += 0.01 * obj.userData.pulseDirection;
                if (obj.userData.scale > 1.2 || obj.userData.scale < 0.8) {
                    obj.userData.pulseDirection *= -1;
                }
                obj.scale.setScalar(obj.userData.scale);
                obj.rotation.y += obj.userData.rotationSpeed;
            });
        }
    </script>
</body>
</html>
